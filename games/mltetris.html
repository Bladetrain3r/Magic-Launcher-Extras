<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>MLTetris - Seven Shapes, Infinite Gameplay</title>
    <style>
        body {
            background: #000;
            color: #0f0;
            font-family: 'Courier New', monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            margin: 0;
        }
        
        h1 {
            color: #0f0;
            text-shadow: 0 0 20px #0f0;
            margin: 10px 0;
            font-size: 36px;
            letter-spacing: 8px;
        }
        
        .tagline {
            color: #080;
            margin-bottom: 20px;
            font-size: 12px;
        }
        
        .game-container {
            display: flex;
            gap: 30px;
            align-items: flex-start;
        }
        
        #game {
            border: 2px solid #0f0;
            box-shadow: 0 0 30px #050;
            background: #000;
        }
        
        .info-panel {
            color: #0f0;
            font-size: 16px;
            min-width: 150px;
        }
        
        .info-item {
            margin: 15px 0;
            padding: 10px;
            border: 1px solid #050;
            background: #010;
        }
        
        .info-label {
            color: #080;
            font-size: 12px;
            display: block;
            margin-bottom: 5px;
        }
        
        .info-value {
            font-size: 24px;
            text-shadow: 0 0 10px currentColor;
        }
        
        #next-piece {
            border: 1px solid #050;
            background: #000;
            box-shadow: 0 0 10px #050;
        }
        
        .controls {
            margin-top: 20px;
            padding: 15px;
            border: 1px solid #050;
            background: #010;
            font-size: 12px;
            line-height: 1.6;
        }
        
        .controls kbd {
            background: #020;
            border: 1px solid #0f0;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 11px;
            box-shadow: 0 0 5px #050;
        }
        
        button {
            background: #010;
            color: #0f0;
            border: 2px solid #0f0;
            padding: 10px 30px;
            font-family: inherit;
            font-size: 16px;
            cursor: pointer;
            margin-top: 20px;
            text-shadow: 0 0 5px #0f0;
            letter-spacing: 2px;
        }

        .trialtris-button {
            background: rgb(255, 44, 192);
            color: #ff00ff;
            border: 2px solid #ff00ff;
            padding: 10px 30px;
            font-family: inherit;
            font-size: 16px;
            cursor: pointer;
            margin-top: 20px;
            text-shadow: 0 0 5px #ff00ff;
            letter-spacing: 2px;
        }
        
        button:hover {
            background: #020;
            box-shadow: 0 0 20px #0f0;
        }
        
        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #000;
            border: 2px solid #f00;
            padding: 20px;
            text-align: center;
            display: none;
            z-index: 100;
        }
        
        .game-over h2 {
            color: #f00;
            text-shadow: 0 0 20px #f00;
            margin: 0 0 10px 0;
        }
        
        .philosophy {
            margin-top: 30px;
            max-width: 500px;
            color: #050;
            font-size: 10px;
            text-align: center;
            line-height: 1.4;
        }
    </style>
</head>
<body>
    <h1>MLTETRIS</h1>
    <div class="tagline">Seven shapes. One rule. Perfection.</div>
    
    <div class="game-container">
        <div class="info-panel">
            <div class="info-item">
                <span class="info-label">SCORE</span>
                <span class="info-value" id="score">0</span>
            </div>
            <div class="info-item">
                <span class="info-label">LINES</span>
                <span class="info-value" id="lines">0</span>
            </div>
            <div class="info-item">
                <span class="info-label">LEVEL</span>
                <span class="info-value" id="level">1</span>
            </div>
            <div class="info-item">
                <span class="info-label">NEXT</span>
                <canvas id="next-piece" width="80" height="80"></canvas>
            </div>
        </div>
        
        <div style="position: relative;">
            <canvas id="game" width="300" height="600"></canvas>
            <div class="game-over" id="gameOver">
                <h2>GAME OVER</h2>
                <p>Score: <span id="finalScore">0</span></p>
                <button onclick="init()">AGAIN</button>
            </div>
        </div>
        
        <div class="info-panel">
            <div class="controls">
                <strong>CONTROLS</strong><br><br>
                <kbd>←</kbd> <kbd>→</kbd> Move<br>
                <kbd>↑</kbd> Rotate<br>
                <kbd>↓</kbd> Soft Drop<br>
                <kbd>SPACE</kbd> Hard Drop<br>
                <kbd>P</kbd> Pause<br><br>
                <em>No hold. No ghost piece.<br>
                No wall kicks.<br>
                Just Tetris.</em>
            </div>
        </div>
    </div>
    
    <button onclick="init()">START GAME</button>
    <button class="trialtris-button" onclick="location.href='trialtris.html'">SUFFER</button>
    
    <div class="philosophy">
        <p>Graphics don't make games. Gameplay makes games.</p>
        <p>Tetris proved this in 1984. Nothing has changed.</p>
        <p>Seven shapes. Clear lines. Perfection achieved.</p>
    </div>

    <script>
        // MLTetris - Tetris in its purest form
        // No hold. No ghost pieces. No modern bullshit.
        // Just blocks falling and lines clearing.
        
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');
        const nextCanvas = document.getElementById('next-piece');
        const nextCtx = nextCanvas.getContext('2d');
        
        const COLS = 10;
        const ROWS = 20;
        const BLOCK_SIZE = 30;
        
        // The seven sacred shapes (I, O, T, S, Z, J, L)
        const PIECES = [
            [[1,1,1,1]],           // I
            [[1,1],[1,1]],         // O
            [[0,1,0],[1,1,1]],     // T
            [[0,1,1],[1,1,0]],     // S
            [[1,1,0],[0,1,1]],     // Z
            [[1,0,0],[1,1,1]],     // J
            [[0,0,1],[1,1,1]],     // L
            [[1,0,1]]              // The Blursed One
        ];
        
        // Perfect colors (not too bright, not too dull)
        const COLORS = [
            '#00ffff', // I - Cyan
            '#ffff00', // O - Yellow
            '#ff00ff', // T - Purple
            '#00ff00', // S - Green
            '#ff0000', // Z - Red
            '#0000ff', // J - Blue
            '#ff8800',  // L - Orange
            '#ff00ff'   // Blursed - Magenta
        ];
        
        let board = [];
        let currentPiece = null;
        let nextPieceType = 0;
        let gameRunning = false;
        let paused = false;
        let dropCounter = 0;
        let lastTime = 0;
        let score = 0;
        let lines = 0;
        let level = 1;
        
        class Piece {
            constructor(type, x, y) {
                this.type = type;
                this.shape = PIECES[type];
                this.color = COLORS[type];
                this.x = x;
                this.y = y;
            }
            
            rotate() {
                // Simple rotation - transpose and reverse
                const N = this.shape.length;
                const M = this.shape[0].length;
                let rotated = Array(M).fill().map(() => Array(N).fill(0));
                
                for (let i = 0; i < N; i++) {
                    for (let j = 0; j < M; j++) {
                        rotated[j][N - 1 - i] = this.shape[i][j];
                    }
                }
                
                // Check if rotation is valid
                const oldShape = this.shape;
                this.shape = rotated;
                if (this.collides()) {
                    this.shape = oldShape; // Can't rotate
                }
            }
            
            collides() {
                for (let y = 0; y < this.shape.length; y++) {
                    for (let x = 0; x < this.shape[y].length; x++) {
                        if (this.shape[y][x]) {
                            const boardX = this.x + x;
                            const boardY = this.y + y;
                            
                            if (boardX < 0 || boardX >= COLS || boardY >= ROWS) {
                                return true;
                            }
                            
                            if (boardY >= 0 && board[boardY][boardX]) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            }
            
            lock() {
                for (let y = 0; y < this.shape.length; y++) {
                    for (let x = 0; x < this.shape[y].length; x++) {
                        if (this.shape[y][x]) {
                            const boardY = this.y + y;
                            const boardX = this.x + x;
                            if (boardY >= 0) {
                                board[boardY][boardX] = this.color;
                            }
                        }
                    }
                }
            }
        }
        
        function init() {
            // Clear board
            board = Array(ROWS).fill().map(() => Array(COLS).fill(0));
            
            // Reset stats
            score = 0;
            lines = 0;
            level = 1;
            updateStats();
            
            // Hide game over
            document.getElementById('gameOver').style.display = 'none';
            
            // Start game
            nextPieceType = Math.floor(Math.random() * PIECES.length);
            spawnPiece();
            gameRunning = true;
            paused = false;
            lastTime = 0;
            
            // Start game loop
            requestAnimationFrame(gameLoop);
        }
        
        function spawnPiece() {
            const type = nextPieceType;
            nextPieceType = Math.floor(Math.random() * PIECES.length);
            
            const piece = new Piece(type, 3, 0);
            
            // Adjust spawn position for different pieces
            if (type === 0) piece.x = 3; // I piece
            if (type === 1) piece.x = 4; // O piece
            
            currentPiece = piece;
            
            // Check game over
            if (currentPiece.collides()) {
                gameOver();
            }
            
            drawNext();
        }
        
        function gameLoop(time = 0) {
            if (!gameRunning) return;
            
            const deltaTime = time - lastTime;
            lastTime = time;
            
            if (!paused) {
                dropCounter += deltaTime;
                
                // Drop speed based on level
                const dropSpeed = Math.max(100, 1000 - (level - 1) * 100);
                
                if (dropCounter > dropSpeed) {
                    drop();
                    dropCounter = 0;
                }
            }
            
            draw();
            requestAnimationFrame(gameLoop);
        }
        
        function drop() {
            currentPiece.y++;
            
            if (currentPiece.collides()) {
                currentPiece.y--;
                currentPiece.lock();
                clearLines();
                spawnPiece();
            }
        }
        
        function clearLines() {
            let linesCleared = 0;
            
            for (let y = ROWS - 1; y >= 0; y--) {
                if (board[y].every(cell => cell !== 0)) {
                    board.splice(y, 1);
                    board.unshift(Array(COLS).fill(0));
                    linesCleared++;
                    y++; // Check same row again
                }
            }
            
            if (linesCleared > 0) {
                lines += linesCleared;
                score += [40, 100, 300, 1200][linesCleared - 1] * level;
                level = Math.floor(lines / 10) + 1;
                updateStats();
            }
        }
        
        function draw() {
            // Clear canvas
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw grid
            ctx.strokeStyle = '#050';
            ctx.lineWidth = 0.5;
            for (let x = 0; x <= COLS; x++) {
                ctx.beginPath();
                ctx.moveTo(x * BLOCK_SIZE, 0);
                ctx.lineTo(x * BLOCK_SIZE, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y <= ROWS; y++) {
                ctx.beginPath();
                ctx.moveTo(0, y * BLOCK_SIZE);
                ctx.lineTo(canvas.width, y * BLOCK_SIZE);
                ctx.stroke();
            }
            
            // Draw board
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    if (board[y][x]) {
                        drawBlock(x, y, board[y][x]);
                    }
                }
            }
            
            // Draw current piece
            if (currentPiece) {
                for (let y = 0; y < currentPiece.shape.length; y++) {
                    for (let x = 0; x < currentPiece.shape[y].length; x++) {
                        if (currentPiece.shape[y][x]) {
                            drawBlock(
                                currentPiece.x + x,
                                currentPiece.y + y,
                                currentPiece.color
                            );
                        }
                    }
                }
            }
        }
        
        function drawBlock(x, y, color) {
            ctx.fillStyle = color;
            ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE - 1, BLOCK_SIZE - 1);
            
            // Simple 3D effect
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE - 1, 3);
            ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, 3, BLOCK_SIZE - 1);
            
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(x * BLOCK_SIZE + BLOCK_SIZE - 3, y * BLOCK_SIZE, 2, BLOCK_SIZE - 1);
            ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE + BLOCK_SIZE - 3, BLOCK_SIZE - 1, 2);
        }
        
        function drawNext() {
            nextCtx.fillStyle = '#000';
            nextCtx.fillRect(0, 0, nextCanvas.width, nextCanvas.height);
            
            const piece = PIECES[nextPieceType];
            const color = COLORS[nextPieceType];
            const blockSize = 20;
            
            const offsetX = (nextCanvas.width - piece[0].length * blockSize) / 2;
            const offsetY = (nextCanvas.height - piece.length * blockSize) / 2;
            
            for (let y = 0; y < piece.length; y++) {
                for (let x = 0; x < piece[y].length; x++) {
                    if (piece[y][x]) {
                        nextCtx.fillStyle = color;
                        nextCtx.fillRect(
                            offsetX + x * blockSize,
                            offsetY + y * blockSize,
                            blockSize - 1,
                            blockSize - 1
                        );
                    }
                }
            }
        }
        
        function hardDrop() {
            while (!currentPiece.collides()) {
                currentPiece.y++;
                score += 2;
            }
            currentPiece.y--;
            currentPiece.lock();
            clearLines();
            spawnPiece();
            updateStats();
        }
        
        function gameOver() {
            gameRunning = false;
            document.getElementById('finalScore').textContent = score;
            document.getElementById('gameOver').style.display = 'block';
        }
        
        function updateStats() {
            document.getElementById('score').textContent = score;
            document.getElementById('lines').textContent = lines;
            document.getElementById('level').textContent = level;
        }
        
        // Controls
        document.addEventListener('keydown', (e) => {
            if (!gameRunning || paused) {
                if (e.key === 'p' || e.key === 'P') {
                    paused = false;
                }
                return;
            }
            
            switch(e.key) {
                case 'ArrowLeft':
                    currentPiece.x--;
                    if (currentPiece.collides()) currentPiece.x++;
                    break;
                case 'ArrowRight':
                    currentPiece.x++;
                    if (currentPiece.collides()) currentPiece.x--;
                    break;
                case 'ArrowUp':
                    currentPiece.rotate();
                    break;
                case 'ArrowDown':
                    drop();
                    score++;
                    updateStats();
                    break;
                case ' ':
                    hardDrop();
                    break;
                case 'p':
                case 'P':
                    paused = true;
                    break;
            }
        });
        
        // Draw initial empty board
        draw();
        
        /*
         * MLTetris - The Truth
         * 
         * No hold queue (cowardice)
         * No ghost piece (training wheels)
         * No fancy rotations (unnecessary)
         * No special effects (distraction)
         * 
         * Just blocks falling.
         * Lines clearing.
         * Score increasing.
         * 
         * This is all Tetris ever needed to be.
         * This is all Tetris needs to be.
         * 
         * Seven shapes. One rule. Perfection.
         */
    </script>
</body>
</html>