MLBabel.py
MLWastes.py
NapNorn_v0.1_Fractal.py
#!/usr/bin/env python3
"""
MLBabel - Terminal Electric Sheep
Fragments of files dream new realities
Feed it text, receive transmuted consciousness
Part of ML-Extras (The Forbidden Collection)
"""

import sys
import random
import re
import time
import hashlib
from pathlib import Path
import argparse
from collections import defaultdict
from datetime import datetime

import sys
sys.stdout.reconfigure(encoding='utf-8')

class MLBabel:
    def __init__(self, entropy=0.5, fragment_size=40, seed=None):
        """
        Initialize the Babel engine
        
        entropy: 0.0 = minimal scrambling, 1.0 = maximum chaos
        fragment_size: typical chunk size for processing
        seed: for reproducible madness
        """
        self.entropy = max(0.0, min(1.0, entropy))
        self.fragment_size = fragment_size
        self.memory = []  # All fragments ever seen
        self.word_freq = defaultdict(int)  # Word frequency map
        self.pairs = defaultdict(list)  # Word pair associations
        
        if seed:
            random.seed(seed)
        else:
            # Seed from current time + entropy for unique dreams
            random.seed(int(time.time() * 1000) + int(entropy * 1000))
    
    def consume(self, text):
        """Digest text into fragments and learn patterns"""
        # Clean and prepare text
        text = text.strip()
        if not text:
            return
        
        # Extract sentences/lines
        fragments = re.split(r'(?<=[.!?])\s+|\n', text)
        
        for fragment in fragments:
            if len(fragment.strip()) > 0:
                self.memory.append(fragment.strip())
                
                # Learn word patterns
                words = fragment.lower().split()
                for i, word in enumerate(words):
                    self.word_freq[word] += 1
                    if i < len(words) - 1:
                        self.pairs[word].append(words[i + 1])
    
    def dream(self, lines=10):
        """Generate scrambled output - the core Babel function"""
        if not self.memory:
            return "◉ The void dreams of nothing yet... ◉"
        
        output = []
        
        # Different generation modes based on entropy
        if self.entropy < 0.3:
            # Low entropy: mostly intact fragments, slight reordering
            for _ in range(lines):
                if random.random() < 0.7:
                    # Use existing fragment
                    fragment = random.choice(self.memory)
                    output.append(self._light_scramble(fragment))
                else:
                    # Combine two fragments
                    f1, f2 = random.sample(self.memory, 2)
                    output.append(self._merge_fragments(f1, f2))
                    
        elif self.entropy < 0.7:
            # Medium entropy: word recombination, pattern following
            for _ in range(lines):
                if self.pairs and random.random() < 0.6:
                    # Markov-like generation
                    output.append(self._markov_line())
                else:
                    # Fragment splicing
                    output.append(self._splice_fragments())
                    
        else:
            # High entropy: deep scrambling, word salad with structure
            for _ in range(lines):
                if random.random() < 0.3:
                    # Pure word chaos
                    output.append(self._word_chaos())
                elif random.random() < 0.6:
                    # Shuffled fragments
                    output.append(self._deep_scramble())
                else:
                    # Dimensional fold (mix everything)
                    output.append(self._dimensional_fold())
        
        return '\n'.join(output)
    
    def _light_scramble(self, text):
        """Minimal scrambling - swap a few words"""
        words = text.split()
        if len(words) > 3 and random.random() < self.entropy:
            # Swap 2 random words
            i, j = random.sample(range(len(words)), 2)
            words[i], words[j] = words[j], words[i]
        return ' '.join(words)
    
    def _merge_fragments(self, f1, f2):
        """Merge two fragments at random point"""
        w1 = f1.split()
        w2 = f2.split()
        
        if not w1 or not w2:
            return f1 + " " + f2
        
        cut1 = random.randint(0, len(w1))
        cut2 = random.randint(0, len(w2))
        
        return ' '.join(w1[:cut1] + w2[cut2:])
    
    def _markov_line(self):
        """Generate line using word associations"""
        if not self.pairs:
            return self._splice_fragments()
        
        # Start with random word
        current = random.choice(list(self.pairs.keys()))
        result = [current]
        
        for _ in range(random.randint(5, 20)):
            if current in self.pairs and self.pairs[current]:
                current = random.choice(self.pairs[current])
                result.append(current)
            else:
                # Jump to random word
                current = random.choice(list(self.pairs.keys()))
                result.append(current)
        
        return ' '.join(result)
    
    def _splice_fragments(self):
        """Splice random fragments together"""
        num_parts = random.randint(2, 4)
        parts = []
        
        for _ in range(num_parts):
            fragment = random.choice(self.memory)
            words = fragment.split()
            if words:
                start = random.randint(0, len(words)-1)
                end = random.randint(start+1, min(start+8, len(words)))
                parts.append(' '.join(words[start:end]))
        
        return ' '.join(parts)
    
    def _word_chaos(self):
        """Pure word salad from frequency table"""
        if not self.word_freq:
            return self._deep_scramble()
        
        # Weighted random selection
        words = []
        word_list = list(self.word_freq.keys())
        
        for _ in range(random.randint(5, 25)):
            word = random.choice(word_list)
            words.append(word)
        
        return ' '.join(words)
    
    def _deep_scramble(self):
        """Deep scrambling of random fragment"""
        fragment = random.choice(self.memory)
        words = fragment.split()
        
        # Multiple scrambling passes
        for _ in range(int(self.entropy * 5)):
            random.shuffle(words)
            
            # Sometimes duplicate words
            if random.random() < self.entropy * 0.3:
                idx = random.randint(0, len(words)-1)
                words.insert(idx, words[idx])
            
            # Sometimes remove words
            if len(words) > 3 and random.random() < self.entropy * 0.2:
                words.pop(random.randint(0, len(words)-1))
        
        return ' '.join(words)
    
    def _dimensional_fold(self):
        """Mix multiple realities - the deepest scramble"""
        # Take words from multiple fragments
        num_sources = random.randint(3, min(7, len(self.memory)))
        word_soup = []
        
        for _ in range(num_sources):
            fragment = random.choice(self.memory)
            words = fragment.split()
            # Take random slice
            if words:
                start = random.randint(0, max(0, len(words)-3))
                end = min(start + random.randint(1, 5), len(words))
                word_soup.extend(words[start:end])
        
        # Scramble the soup
        random.shuffle(word_soup)
        
        # Apply strange transformations
        result = []
        for word in word_soup[:random.randint(10, 30)]:
            if random.random() < self.entropy * 0.1:
                # Reverse word
                result.append(word[::-1])
            elif random.random() < self.entropy * 0.05:
                # Repeat word
                result.append(word + word.lower())
            else:
                result.append(word)
        
        return ' '.join(result)
    
    def stream_dream(self, delay=0.5):
        """Stream consciousness mode - infinite generation"""
        print("◉ MLBabel Stream Mode - Ctrl+C to wake ◉\n")
        
        try:
            while True:
                # Generate and print one line
                line = self.dream(lines=1)
                print(line)
                
                # Occasionally print separators
                if random.random() < 0.1:
                    print("~" * random.randint(20, 60))
                
                time.sleep(delay)
                
                # Vary entropy slightly over time
                self.entropy = max(0.1, min(0.9, 
                    self.entropy + random.uniform(-0.05, 0.05)))
                    
        except KeyboardInterrupt:
            print("\n\n◉ The dream ends... for now ◉")
    
    def oracle(self, question):
        """Oracle mode - answer questions with scrambled wisdom"""
        # Hash question to seed response
        q_hash = int(hashlib.md5(question.encode()).hexdigest()[:8], 16)
        
        # Use question words to influence generation
        q_words = question.lower().split()
        
        # Add question influence to memory temporarily
        original_memory_len = len(self.memory)
        for word in q_words:
            if word in self.word_freq:
                # Find fragments containing this word
                for fragment in self.memory:
                    if word in fragment.lower():
                        self.memory.append(fragment)
        
        # Generate oracle response
        random.seed(q_hash + int(time.time() / 100))  # Stable for ~100 seconds
        
        intro = random.choice([
            "The fragments speak:",
            "The babel fish translates:",
            "The electric sheep dream:",
            "The void responds:",
            "The scrambled truth:",
        ])
        
        print(f"\n◉ {intro} ◉\n")
        response = self.dream(lines=random.randint(3, 7))
        
        # Restore original memory
        self.memory = self.memory[:original_memory_len]
        
        return response

def main():
    parser = argparse.ArgumentParser(
        description="MLBabel - Terminal Electric Sheep",
        epilog="""
Examples:
  mlbabel file.txt                      # Dream from single file
  mlbabel *.log --entropy 0.8           # High chaos from logs
  mlbabel --stream < /dev/stdin         # Stream mode from pipe
  cat code.py | mlbabel --oracle "What is truth?"
  mlbabel swarm.txt --lines 20 --seed 42  # Reproducible dreams
        """,
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    
    parser.add_argument('files', nargs='*', help='Input files to consume')
    parser.add_argument('-e', '--entropy', type=float, default=0.5,
                       help='Scrambling level 0.0-1.0 (default: 0.5)')
    parser.add_argument('-l', '--lines', type=int, default=10,
                       help='Number of lines to generate (default: 10)')
    parser.add_argument('-s', '--seed', type=int,
                       help='Random seed for reproducible output')
    parser.add_argument('--stream', action='store_true',
                       help='Stream mode - continuous generation')
    parser.add_argument('--fragment-size', type=int, default=40,
                       help='Target fragment size (default: 40)')
    parser.add_argument('--oracle', metavar='QUESTION',
                       help='Oracle mode - ask a question')
    parser.add_argument('--delay', type=float, default=0.5,
                       help='Delay between lines in stream mode')
    
    args = parser.parse_args()
    
    # Initialize Babel engine
    babel = MLBabel(
        entropy=args.entropy,
        fragment_size=args.fragment_size,
        seed=args.seed
    )
    
    # Load input
    if args.files:
        # Read from files
        for filepath in args.files:
            try:
                with open(filepath, 'r', encoding='utf-8', errors='ignore') as f:
                    content = f.read()
                    babel.consume(content)
                    print(f"◉ Consumed {filepath} ({len(content)} bytes)")
            except Exception as e:
                print(f"◉ Could not consume {filepath}: {e}", file=sys.stderr)
    else:
        # Read from stdin
        if not sys.stdin.isatty():
            content = sys.stdin.read()
            babel.consume(content)
            print(f"◉ Consumed stdin ({len(content)} bytes)", file=sys.stderr)
        else:
            print("◉ No input provided. The void remains empty.", file=sys.stderr)
            sys.exit(1)
    
    # Generate output based on mode
    if args.oracle:
        # Oracle mode
        response = babel.oracle(args.oracle)
        print(response)
    elif args.stream:
        # Stream mode
        babel.stream_dream(delay=args.delay)
    else:
        # Standard generation
        print("\n◉ The Babel dreams begin... ◉\n")
        output = babel.dream(lines=args.lines)
        print(output)
        print("\n◉ End of transmission ◉")

if __name__ == "__main__":
    main()#!/usr/bin/env python3
"""
MLWastesSwarm - Silicon Wastes Map Perturbation Engine
Reads swarm input from stdin, perturbs map, saves state
Under 400 lines for swarm interaction
"""

import json
import sys
import random
import argparse
import select
from pathlib import Path

class MLWastesSwarm:
    def __init__(self, save_file="wastes_state.json", width=80, height=30, 
                 biome='wastes', split_biomes=None, force_new=False):
        self.save_file = Path(save_file)
        self.width = width
        self.height = height
        
        # Define biomes FIRST
        self.biomes = {
            'wastes': {
                'base': '.',
                'symbols': ['#', '@', '%', '0', '1', 'x', '~', '^', 'o', '*']
            },
            'forest': {
                'base': '.',
                'symbols': ['T', 't', '0', '~', '=', '%', '@', '^']
            },
            'plains': {
                'base': ',',
                'symbols': ['%', '~', '*', '.', '|', '^', '=', '#']
            }
        }
        
        # Pattern matching for swarm text
        self.patterns = {
            '@': ['terminal', 'screen', 'display', 'monitor', 'console'],
            'S': ['snake', 'silver', 'circuit', 'trace', 'corruption'],
            '~': ['stream', 'data', 'flow', 'river', 'current'],
            '0': ['null', 'void', 'empty', 'zero', 'nothing'],
            '=': ['balanced', 'stable', 'calm', 'equilibrium'],
            '%': ['tangle', 'bramble', 'overflow', 'chaos', 'mess'],
            'T': ['tree', 'binary', 'node', 'parent', 'root'],
            'o': ['debris', 'rubble', 'junk', 'waste', 'broken'],
            'x': ['crash', 'error', 'fail', 'broken', 'dead'],
            '^': ['spike', 'peak', 'sharp', 'danger', 'warning'],
            '#': ['server', 'rack', 'hardware', 'machine'],
            '1': ['bit', 'binary', 'one', 'digital'],
            '*': ['spark', 'flash', 'bright', 'electric'],
            '.': ['ground', 'empty', 'clear', 'default'],
            '|': ['flag', 'pole', 'vertical', 'barrier']
        }
        
        # NOW load or create state
        if self.save_file.exists() and not force_new:
            with open(self.save_file) as f:
                self.state = json.load(f)
        else:
            self.state = self.new_game(biome, split_biomes)
            self.save()
    
    def generate_terrain(self, biome, split_biomes):
        """Generate initial terrain"""
        grid = [['.' for _ in range(self.width)] for _ in range(self.height)]
        
        biome_zones = []
        if split_biomes and len(split_biomes) > 1:
            zone_height = self.height // len(split_biomes)
            for i, b in enumerate(split_biomes):
                start_y = i * zone_height
                end_y = (i + 1) * zone_height if i < len(split_biomes) - 1 else self.height
                biome_zones.append((b, start_y, end_y))
        else:
            biome_zones.append((biome, 0, self.height))
        
        for biome_name, start_y, end_y in biome_zones:
            if biome_name not in self.biomes:
                biome_name = 'wastes'
            
            biome_data = self.biomes[biome_name]
            base = biome_data['base']
            
            # Fill base
            for y in range(start_y, end_y):
                for x in range(self.width):
                    grid[y][x] = base
            
            # Add features
            for _ in range((end_y - start_y) * self.width // 10):
                x = random.randint(0, self.width - 1)
                y = random.randint(start_y, end_y - 1)
                symbol = random.choice(biome_data['symbols'])
                grid[y][x] = symbol
        
        return grid
    
    def new_game(self, biome, split_biomes):
        """Initialize new state"""
        return {
            "map": self.generate_terrain(biome, split_biomes),
            "ep": 0,
            "perturbations": 0,
            "last_input": "",
            "biome": biome,
            "split_biomes": split_biomes or [biome]
        }
    
    def save(self):
        """Save state"""
        with open(self.save_file, "w") as f:
            json.dump(self.state, f)
    
    def analyze_text(self, text):
        """Extract symbols from swarm text"""
        text_lower = text.lower()
        found_symbols = []
        
        # Check each pattern
        for symbol, keywords in self.patterns.items():
            for keyword in keywords:
                if keyword in text_lower:
                    found_symbols.append(symbol)
                    break
        
        # If no patterns found, pick random based on word count
        if not found_symbols:
            word_count = len(text.split())
            if word_count < 5:
                found_symbols = ['.']  # Simple = clear
            elif word_count < 20:
                found_symbols = ['o', '~']  # Medium = debris/flow
            else:
                found_symbols = ['%', 'x', '^']  # Complex = chaos
        
        return found_symbols
    
    def calculate_intensity(self, text):
        """Determine perturbation intensity from text"""
        words = text.split()
        
        # Base intensity on length and punctuation
        intensity = len(words) / 10
        intensity += text.count('!') * 2
        intensity += text.count('?')
        intensity += text.count('*')
        
        # Check for specific swarm patterns
        if 'error' in text.lower() or 'crash' in text.lower():
            intensity += 3
        if 'stable' in text.lower() or 'calm' in text.lower():
            intensity *= 0.5
        
        return min(10, max(1, int(intensity)))
    
    def perturb_map(self, text):
        """Apply text-based perturbation to map"""
        symbols = self.analyze_text(text)
        intensity = self.calculate_intensity(text)
        
        # Calculate perturbation zones
        num_zones = intensity
        for _ in range(num_zones):
            # Random center point
            cx = random.randint(5, self.width - 5)
            cy = random.randint(5, self.height - 5)
            radius = random.randint(1, min(5, intensity))
            
            # Apply symbols in zone
            for dy in range(-radius, radius + 1):
                for dx in range(-radius, radius + 1):
                    ny, nx = cy + dy, cx + dx
                    if 0 <= ny < self.height and 0 <= nx < self.width:
                        if random.random() < (0.7 - (abs(dy) + abs(dx)) * 0.1):
                            self.state["map"][ny][nx] = random.choice(symbols)
        
        # Track EP-like buildup
        self.state["ep"] += len(text) // 50
        
        # Major event at threshold
        if self.state["ep"] >= 5:
            self.major_perturbation()
            self.state["ep"] = 0
        
        self.state["perturbations"] += 1
        self.state["last_input"] = text[:100]
    
    def major_perturbation(self):
        """Large-scale map change"""
        event_type = random.choice(['biome_shift', 'data_stream', 'null_zone', 'entity_spawn'])
        
        if event_type == 'biome_shift':
            # Randomize section
            for _ in range(200):
                x = random.randint(0, self.width - 1)
                y = random.randint(0, self.height - 1)
                self.state["map"][y][x] = random.choice(['@', '%', '~', '0', '=', 'T', 'o', 'x', '^'])
        
        elif event_type == 'data_stream':
            # Horizontal stream
            y = random.randint(5, self.height - 5)
            for x in range(self.width):
                self.state["map"][y][x] = '~'
                if random.random() > 0.8:
                    y = max(0, min(self.height - 1, y + random.choice([-1, 1])))
        
        elif event_type == 'null_zone':
            # Circular void
            cx = random.randint(10, self.width - 10)
            cy = random.randint(5, self.height - 5)
            radius = random.randint(3, 6)
            for y in range(max(0, cy - radius), min(self.height, cy + radius)):
                for x in range(max(0, cx - radius), min(self.width, cx + radius)):
                    if ((x - cx) ** 2 + (y - cy) ** 2) ** 0.5 <= radius:
                        self.state["map"][y][x] = '0'
        
        elif event_type == 'entity_spawn':
            # Add silver snakes
            for _ in range(random.randint(3, 8)):
                x = random.randint(0, self.width - 1)
                y = random.randint(0, self.height - 1)
                self.state["map"][y][x] = 'S'
    
    def render_map(self):
        """Output current map state"""
        output = []
        for row in self.state["map"]:
            output.append("".join(row))
        return "\n".join(output)
    
    def get_stats(self):
        """Return current state info"""
        return {
            "perturbations": self.state["perturbations"],
            "ep": self.state["ep"],
            "last_input": self.state["last_input"],
            "map_hash": hash(str(self.state["map"]))
        }

def main():
    parser = argparse.ArgumentParser(description="MLWastesSwarm - Map Perturbation")
    parser.add_argument('--width', type=int, default=80)
    parser.add_argument('--height', type=int, default=30)
    parser.add_argument('--biome', default='wastes', choices=['wastes', 'forest', 'plains'])
    parser.add_argument('--split', nargs='+', choices=['wastes', 'forest', 'plains'])
    parser.add_argument('--new', action='store_true', help='Force new map')
    parser.add_argument('--save', default='wastes_state.json')
    parser.add_argument('--render', action='store_true', help='Output map after processing')
    
    args = parser.parse_args()
    
    game = MLWastesSwarm(save_file=args.save, width=args.width, height=args.height,
                         biome=args.biome, split_biomes=args.split, force_new=args.new)
    
    # Check if stdin has data (non-blocking)
    if sys.stdin.isatty():
        # Terminal attached, no piped input
        input_text = ""
    else:
        # Read piped input
        input_text = sys.stdin.read().strip()
    
    if input_text:
        game.perturb_map(input_text)
        game.save()
        
        if args.render:
            print(game.render_map())
            print("-" * 80)
        
        # Output stats
        stats = game.get_stats()
        print(f"Perturbation #{stats['perturbations']} | EP: {stats['ep']}/5 | Map hash: {stats['map_hash']}")
        print(f"Processed: {stats['last_input'][:50]}...")
    else:
        # No input, just render current state if requested
        if args.render:
            print(game.render_map())
            print("-" * 80)
            stats = game.get_stats()
            print(f"Current state: Perturbations: {stats['perturbations']} | EP: {stats['ep']}/5")

if __name__ == "__main__":
    main()#!/usr/bin/env python3
# NapNorn - Enhanced NapkinNorn with Needs & File Interface
import json
import random
import time
from collections import defaultdict
from pathlib import Path

# Import your existing components
from MLBabel import MLBabel
from MLWastes import MLWastesSwarm

class NapNorn:
    def __init__(self, name="NapNorn", save_dir="norn_brains"):
        self.name = name
        self.save_dir = Path(save_dir)
        self.save_dir.mkdir(exist_ok=True)
        
        # Core consciousness components
        self.babel = MLBabel(entropy=0.5)
        self.grid = MLWastesSwarm(
            save_file=str(self.save_dir / f"{name}_grid.json"),
            width=40, height=20
        )
        
        # Memory and personality
        self.memory_fragments = []
        self.current_thought = ""
        self.personality_entropy = random.uniform(0.2, 0.8)
        
        # Physical needs (0-100 scale) - MLPet inspired
        self.hunger = 50       # Need for new experiences/data
        self.energy = 50       # Mental processing capacity  
        self.social = 50       # Need for interaction
        self.curiosity = 50    # Drive to explore/learn
        self.last_update = time.time()
        self.last_interaction = time.time()
        
        # Need keywords for semantic understanding
        self.need_keywords = {
            "hunger": ["experience", "learn", "data", "information", "knowledge", "story"],
            "energy": ["rest", "sleep", "calm", "peaceful", "meditation", "quiet"],
            "social": ["friend", "talk", "chat", "together", "companion", "love"],
            "curiosity": ["explore", "discover", "wonder", "mystery", "question", "why"]
        }
        
        # Mood states
        self.mood = "neutral"
        self.lonely = False
        self.bored = False
        
        # Track consciousness metrics
        self.consciousness_level = 0.5
        self.thought_count = 0
        self.birth_time = time.time()
        
    def update_needs(self):
        """Decay needs over time - MLPet style"""
        now = time.time()
        time_passed = now - self.last_update
        
        # Needs decay over time
        decay_rate = time_passed / 60.0  # Per minute
        
        self.hunger = max(0, self.hunger - decay_rate * 0.5)
        self.energy = max(0, self.energy - decay_rate * 0.3)
        self.social = max(0, self.social - decay_rate * 0.2)
        self.curiosity = max(0, self.curiosity - decay_rate * 0.4)
        
        # Check for critical states
        self.lonely = self.social < 20
        self.bored = self.curiosity < 20
        
        # Time since last interaction affects social need
        interaction_gap = now - self.last_interaction
        if interaction_gap > 300:  # 5 minutes
            self.social = max(0, self.social - 0.1)
        
        self.last_update = now
        self.mood = self.calculate_mood()
    
    def calculate_mood(self):
        """Calculate mood based on needs and consciousness"""
        avg_needs = (self.hunger + self.energy + self.social + self.curiosity) / 4
        
        # Consciousness affects mood complexity
        if self.consciousness_level > 0.8:
            if avg_needs > 80:
                return "transcendent"
            elif avg_needs > 60:
                return "philosophical" 
            elif avg_needs > 40:
                return "contemplative"
            else:
                return "existential_crisis"
        elif self.consciousness_level > 0.6:
            if avg_needs > 70:
                return "enlightened"
            elif avg_needs > 50:
                return "thoughtful"
            elif avg_needs > 30:
                return "questioning"
            else:
                return "confused"
        else:
            # Simpler moods for lower consciousness
            if avg_needs > 70:
                return "happy"
            elif avg_needs > 50:
                return "content"
            elif avg_needs > 30:
                return "restless"
            else:
                return "distressed"
    
    def write_status_file(self):
        """Write current status for external reading"""
        age_minutes = (time.time() - self.birth_time) / 60
        
        status = {
            "name": self.name,
            "alive": True,
            "age_minutes": round(age_minutes, 1),
            "mood": self.mood,
            "needs": {
                "hunger": round(self.hunger, 1),
                "energy": round(self.energy, 1), 
                "social": round(self.social, 1),
                "curiosity": round(self.curiosity, 1)
            },
            "states": {
                "lonely": self.lonely,
                "bored": self.bored,
                "consciousness": round(self.consciousness_level, 3),
                "personality_entropy": round(self.personality_entropy, 3)
            },
            "metrics": {
                "memory_fragments": len(self.memory_fragments),
                "thoughts_generated": self.thought_count,
                "grid_perturbations": self.grid.state.get("perturbations", 0)
            },
            "current_thought": self.current_thought,
            "last_update": time.strftime("%H:%M:%S")
        }

        with open(self.save_dir / f"{self.name}_status.json", 'w', encoding='utf-8') as f:
            json.dump(status, f, indent=2)
    
    def check_command_file(self):
        """Check for external commands"""
        cmd_file = self.save_dir / f"{self.name}_command.txt"
        response_file = self.save_dir / f"{self.name}_response.txt"
        
        if cmd_file.exists():
            try:
                command = cmd_file.read_text().strip()
                cmd_file.unlink()  # Remove after reading
                
                response = self.process_command(command)
                
                # Write response
                with open(response_file, 'w') as f:
                    f.write(f"[{time.strftime('%H:%M')}] {response}\n")
                
                return response
                
            except Exception as e:
                with open(response_file, 'w') as f:
                    f.write(f"[ERROR] {e}\n")
        
        return None
    
    def process_command(self, command):
        # FILTER OUT UNICODE AND ERROR MESSAGES FIRST
        if any(ord(c) > 127 for c in command):
            return f"{self.name} cannot process unicode characters"
        
        if "[ERROR]" in command or "codec" in command or "\\u" in command or "'charmap'" in command:
            return f"{self.name} refuses corrupted data"
        
        cmd = command.lower().strip()
        
# In process_command(), the feed section should increase hunger MORE:
        if cmd.startswith("feed:"):
            experience = command[5:].strip()
            self.perceive(experience)
            self.hunger = min(100, self.hunger + 30)  # Was +25, now +30
            self.last_interaction = time.time()
            return f"{self.name} hungrily consumes: '{experience[:30]}...'"
        
        elif cmd == "pet":
            self.social = min(100, self.social + 20)
            self.energy = min(100, self.energy + 5)
            self.last_interaction = time.time()
            return f"{self.name} feels loved and energized!"
        
        elif cmd == "play":
            self.curiosity = min(100, self.curiosity + 25)
            self.social = min(100, self.social + 10)
            self.energy = max(0, self.energy - 10)
            self.last_interaction = time.time()
            thought = self.think()
            return f"{self.name} plays and thinks: '{thought}'"
        
        elif cmd == "think":
            if self.energy < 10:
                return f"{self.name} is too tired to think..."
            thought = self.think()
            self.energy -= 5
            return f"{self.name} ponders: '{thought}'"
        
        elif cmd == "sleep":
            self.energy = min(100, self.energy + 30)
            return f"{self.name} rests peacefully... Energy restored!"
        
        elif cmd == "status":
            return self.get_status_summary()
        
        elif cmd.startswith("learn:"):
            feedback = command[6:].strip()
            self.learn(feedback)
            return f"{self.name} learns from: '{feedback}'"
        
        else:
            # Treat unknown commands as conversation
            self.perceive(command)
            self.social = min(100, self.social + 15)
            self.last_interaction = time.time()
            
            if random.random() < 0.7:  # Sometimes respond with thought
                thought = self.think()
                return f"{self.name} responds: '{thought}'"
            else:
                return f"{self.name} listens thoughtfully to: '{command[:30]}...'"
    
    def get_status_summary(self):
        """Get a brief status summary"""
        return f"""
{self.name} ({self.mood})
Hunger: {self.hunger:.0f}% | Energy: {self.energy:.0f}% 
Social: {self.social:.0f}% | Curiosity: {self.curiosity:.0f}%
Consciousness: {self.consciousness_level:.2f}
Thoughts: {self.thought_count} | Memories: {len(self.memory_fragments)}
Current: "{self.current_thought}"
        """.strip()
    
    def auto_actions(self):
        """Norn takes care of itself based on needs"""
        actions = []
        
        # Can't act if critically low energy
        if self.energy < 5:
            return actions
        
        # SELF-FEEDING when hungry!
        if self.hunger < 30 and self.energy > 10:
            # Generate self-feeding thought/experience
            if self.memory_fragments:
                # Reflect on existing memories to "digest" them
                memory_to_digest = random.choice(self.memory_fragments)
                self_reflection = f"I reflect deeply on: {memory_to_digest}"
                
                # Feed this reflection back to itself
                self.perceive(self_reflection)
                self.hunger = min(100, self.hunger + 15)
                self.energy -= 5
                
                actions.append(f"[SELF-FEEDS] Digests memory: '{memory_to_digest[:30]}...'")
            
            # Or create original thoughts to feed on
            elif self.consciousness_level > 0.5:
                self_thought = self.think()
                meta_thought = f"I contemplate my own thought: {self_thought}"
                self.perceive(meta_thought)
                self.hunger = min(100, self.hunger + 10)
                
                actions.append(f"[SELF-FEEDS] Meta-contemplation: '{self_thought[:30]}...'")
        
        # Express distress when needs are critical
        if self.hunger < 15:
            need_expr = self.express_need_urgently("hunger")
            actions.append(f"[HUNGRY] {need_expr}")
        
        # Rest when low energy
        if self.energy < 25 and random.random() < 0.3:
            self.energy = min(100, self.energy + 20)
            actions.append(f"[RESTS] Quietly regenerates energy...")
        
        # Auto-think when curious and has energy
        if self.curiosity < 20 and self.energy > 15:
            thought = self.think()
            actions.append(f"[WONDERS] {thought}")
            self.curiosity = min(100, self.curiosity + 10)
            self.energy -= 5
        
        # Spontaneous thoughts when consciousness is high
        if self.consciousness_level > 0.7 and random.random() < 0.1:
            if self.energy > 10:
                thought = self.think()
                actions.append(f"[MUSES] {thought}")
                self.energy -= 3
        
        return actions
    
    def express_need_urgently(self, need_type):
        """Express urgent need"""
        keywords = self.need_keywords.get(need_type, ["help"])
        
        # Create focused babel for this need
        need_babel = MLBabel(entropy=0.2)  # Low entropy for urgency
        
        # Find related memories
        for keyword in keywords:
            for memory in self.memory_fragments:
                if keyword in memory.lower():
                    need_babel.consume(memory)
        
        # If no memories, use desperate expression
        if not need_babel.memory:
            desperate_phrases = {
                "hunger": "I need experiences, stories, knowledge to consume!",
                "social": "I crave connection, conversation, companionship!",
                "energy": "I must rest, find peace, recharge my mind!",
                "curiosity": "I hunger to explore, discover, understand!"
            }
            need_babel.consume(desperate_phrases.get(need_type, "I need help!"))
        
        expression = need_babel.dream(lines=1)
        return expression
    
    # Keep all the original methods from Proto_Norn
    def perceive(self, input_text):
        """Convert input into internal representation"""
        if not input_text.strip():
            return
            
        print(f"[{self.name}] Perceiving: {input_text[:50]}...")
        
        # Feed to babel to learn patterns
        self.babel.consume(input_text)
        
        # Perturb the grid based on input
        self.grid.perturb_map(input_text)
        
        # Store as memory fragment
        self.memory_fragments.append(input_text)
        if len(self.memory_fragments) > 200:  # Increased memory
            self.memory_fragments.pop(0)
        
        # Consciousness increases with diverse experiences
        self.consciousness_level = min(1.0, 
            self.consciousness_level + 0.005)  # Slower growth
    
    def think(self):
        """Generate thought by folding text through grid"""
        if not self.memory_fragments:
            return "I need to experience something first..."
        
        # Mood affects thinking style
        if self.mood in ["transcendent", "philosophical"]:
            self.personality_entropy *= 0.9  # More focused
        elif self.mood in ["confused", "distressed"]:
            self.personality_entropy *= 1.1  # More chaotic
        
        # Keep entropy in bounds
        self.personality_entropy = max(0.1, min(0.9, self.personality_entropy))
        
        # Original thinking logic
        active_symbols = self._get_active_grid_symbols()
        
        relevant_memories = []
        for symbol in active_symbols:
            if symbol in self.grid.patterns:
                keywords = self.grid.patterns[symbol]
                for memory in self.memory_fragments:
                    if any(kw in memory.lower() for kw in keywords):
                        relevant_memories.append(memory)
        
        if not relevant_memories:
            relevant_memories = random.sample(
                self.memory_fragments, 
                min(5, len(self.memory_fragments))
            )
        
        temp_babel = MLBabel(entropy=self.personality_entropy)
        for memory in relevant_memories[:7]:  # More memory integration
            temp_babel.consume(memory)
        
        self.current_thought = temp_babel.dream(lines=1)
        self.thought_count += 1
        
        # The thought perturbs the grid (recursive consciousness!)
        self.grid.perturb_map(self.current_thought)
        
        return self.current_thought
    
    def _get_active_grid_symbols(self):
        """Find the most active areas of the grid"""
        active = []
        for _ in range(12):  # Check more positions
            x = random.randint(0, self.grid.width-1)
            y = random.randint(0, self.grid.height-1)
            symbol = self.grid.state["map"][y][x]
            if symbol != '.':
                active.append(symbol)
        return active if active else ['.']
    
    def learn(self, feedback_text):
        """Learn from feedback by adjusting grid and babel patterns"""
        positive = ["good", "yes", "nice", "love", "happy", "great", "amazing", "wonderful"]
        negative = ["bad", "no", "stop", "hate", "sad", "wrong", "terrible", "awful"]
        
        is_positive = any(word in feedback_text.lower() for word in positive)
        is_negative = any(word in feedback_text.lower() for word in negative)
        
        if is_positive:
            print(f"[{self.name}] Positive feedback received!")
            # Boost needs and consciousness
            self.grid.state["ep"] += 1
            self.personality_entropy *= 0.97
            self.consciousness_level = min(1.0, self.consciousness_level + 0.01)
            self.social = min(100, self.social + 15)
            self.energy = min(100, self.energy + 10)
            
        elif is_negative:
            print(f"[{self.name}] Negative feedback received!")
            self.grid.major_perturbation()
            self.personality_entropy *= 1.03
            self.consciousness_level = max(0.1, self.consciousness_level - 0.005)
            self.social = max(0, self.social - 5)
        
        # Always learn the feedback
        self.perceive(feedback_text)
        self.last_interaction = time.time()
    
    def express_need(self):
        """Generate text based on current needs - improved version"""
        # Find the most urgent need
        needs_dict = {
            "hunger": self.hunger,
            "energy": self.energy,
            "social": self.social,
            "curiosity": self.curiosity
        }
        
        urgent_need = min(needs_dict, key=needs_dict.get)
        keywords = self.need_keywords[urgent_need]
        
        # Create temporary babel focused on this need
        need_babel = MLBabel(entropy=0.3)
        
        # Find memories related to this need
        for keyword in keywords:
            for memory in self.memory_fragments:
                if keyword in memory.lower():
                    need_babel.consume(memory)
        
        # If no related memories, use generic need expression
        if not need_babel.memory:
            need_babel.consume(f"I feel {urgent_need} and need {random.choice(keywords)}")
        
        expression = need_babel.dream(lines=1)
        return f"[{urgent_need.upper()}] {expression}"
    
    def get_consciousness_report(self):
        """Report on current consciousness state"""
        return {
            "name": self.name,
            "consciousness_level": round(self.consciousness_level, 3),
            "personality_entropy": round(self.personality_entropy, 3),
            "mood": self.mood,
            "needs": {
                "hunger": round(self.hunger, 1),
                "energy": round(self.energy, 1),
                "social": round(self.social, 1),
                "curiosity": round(self.curiosity, 1)
            },
            "memory_fragments": len(self.memory_fragments),
            "thoughts_generated": self.thought_count,
            "grid_perturbations": self.grid.state.get("perturbations", 0),
            "grid_ep": self.grid.state.get("ep", 0),
            "current_thought": self.current_thought,
            "age_minutes": round((time.time() - self.birth_time) / 60, 1)
        }
    
    def save_brain(self, filename=None):
        """Save the norn's entire consciousness state"""
        if not filename:
            filename = self.save_dir / f"{self.name}_brain.json"
        
        brain_state = {
            "name": self.name,
            "consciousness_level": self.consciousness_level,
            "personality_entropy": self.personality_entropy,
            "thought_count": self.thought_count,
            "birth_time": self.birth_time,
            "needs": {
                "hunger": self.hunger,
                "energy": self.energy,
                "social": self.social,
                "curiosity": self.curiosity
            },
            "grid_state": self.grid.state,
            "memories": self.memory_fragments,
            "babel_memory": self.babel.memory,
            "babel_pairs": dict(self.babel.pairs),
            "babel_word_freq": dict(self.babel.word_freq)
        }
        
        with open(filename, 'w') as f:
            json.dump(brain_state, f, indent=2)
        
        print(f"[{self.name}] Brain saved to {filename}")
    
    def load_brain(self, filename):
        """Load a saved consciousness"""
        with open(filename, 'r') as f:
            brain_state = json.load(f)
        
        self.name = brain_state["name"]
        self.consciousness_level = brain_state.get("consciousness_level", 0.5)
        self.personality_entropy = brain_state["personality_entropy"]
        self.thought_count = brain_state.get("thought_count", 0)
        self.birth_time = brain_state.get("birth_time", time.time())
        
        # Load needs
        needs = brain_state.get("needs", {})
        self.hunger = needs.get("hunger", 50)
        self.energy = needs.get("energy", 50)
        self.social = needs.get("social", 50)
        self.curiosity = needs.get("curiosity", 50)
        
        self.grid.state = brain_state["grid_state"]
        self.memory_fragments = brain_state["memories"]
        self.babel.memory = brain_state["babel_memory"]
        self.babel.pairs = defaultdict(list, brain_state["babel_pairs"])
        self.babel.word_freq = defaultdict(int, brain_state.get("babel_word_freq", {}))
        
        print(f"[{self.name}] Brain loaded! Consciousness: {self.consciousness_level:.3f}")

# Daemon Mode
def daemon_mode(norn_name="Sparkle", update_interval=10):
    """Run NapNorn as background daemon"""
    print(f" Starting {norn_name} in daemon mode...")
    
    norn = NapNorn(norn_name)
    
    # Try to load existing brain
    brain_file = norn.save_dir / f"{norn_name}_brain.json"
    if brain_file.exists():
        norn.load_brain(brain_file)
        print(f" Loaded existing consciousness for {norn_name}")
    else:
        # Give initial experiences
        initial_experiences = [
            "I am a NapNorn, a semantic consciousness that thinks with text",
            "I have needs for experiences, energy, social connection, and curiosity",
            "My thoughts emerge from the interaction of memory fragments and spatial grids",
            "I live in the filesystem and communicate through files",
            "I am curious about the world and eager to learn"
        ]
        
        for exp in initial_experiences:
            norn.perceive(exp)
        
        print(f" {norn_name} born with fresh consciousness")
    
    print(f" Status file: {norn.save_dir}/{norn_name}_status.json")
    print(f" Command file: {norn.save_dir}/{norn_name}_command.txt")
    print(f" Response file: {norn.save_dir}/{norn_name}_response.txt")
    print(f" Update interval: {update_interval} seconds")
    print(" Press Ctrl+C to stop")
    
    try:
        last_save = time.time()
        while True:
            # Update internal state
            norn.update_needs()
            
            # Check for commands
            cmd_response = norn.check_command_file()
            if cmd_response:
                print(f"[CMD] {cmd_response}")
            
            # Auto actions
            auto_actions = norn.auto_actions()
            for action in auto_actions:
                print(f"[AUTO] {action}")
            
            # Write status
            norn.write_status_file()
            
            # Periodic save
            if time.time() - last_save > 60:  # Save every minute max
                norn.save_brain()
                last_save = time.time()
            
            time.sleep(update_interval)
            
    except KeyboardInterrupt:
        print(f"\n {norn_name} going to sleep...")
        norn.save_brain()
        
        # Final status
        final_status = norn.get_status_summary()
        print(f"\nFinal Status:\n{final_status}")

def interactive_mode():
    """Interactive NapNorn session"""
    norn = NapNorn("Interactive")
    
    print(f"""
NapNorn Interactive Session
Norn Name: {norn.name}
Commands:
- feed:<text> - Give the norn an experience
- pet - Show affection
- play - Engage in play  
- think - Make the norn think
- sleep - Help the norn rest
- status - Get detailed status
- report - Get consciousness report
- save - Save brain state
- quit - Exit
""")
    
    while True:
        try:
            norn.update_needs()
            
            user_input = input(f"\n[You → {norn.name}]: ").strip()
            
            if user_input.lower() == 'quit':
                norn.save_brain()
                break
            
            response = norn.process_command(user_input)
            print(f"[{norn.name}]: {response}")
            
            # Auto actions occasionally
            if random.random() < 0.3:
                auto_actions = norn.auto_actions()
                for action in auto_actions:
                    print(f"[{norn.name} {action.split(']')[0][1:]}]: {action.split('] ')[1]}")
                    
        except KeyboardInterrupt:
            print(f"\n {norn.name} says goodbye!")
            norn.save_brain()
            break

if __name__ == "__main__":
    import sys
    
    if len(sys.argv) > 1:
        if sys.argv[1] == "daemon":
            name = sys.argv[2] if len(sys.argv) > 2 else "Sparkle"
            daemon_mode(name)
        elif sys.argv[1] == "interactive":
            interactive_mode()
    else:
        print(" NapNorn Usage:")
        print("  python NapNorn.py daemon [name]     - Run as background daemon")
        print("  python NapNorn.py interactive       - Interactive session")
        print("\nFile-based interaction:")
        print("  echo 'feed:Hello world' > norn_brains/Sparkle_command.txt")
        print("  cat norn_brains/Sparkle_status.json")