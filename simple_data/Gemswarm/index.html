<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MLSwarm K/V Chat</title>
    <!-- Use Tailwind CSS from CDN for a clean, modern look -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom scrollbar for a polished look */
        #chat::-webkit-scrollbar {
            width: 8px;
        }
        #chat::-webkit-scrollbar-track {
            background: #1f2937;
            border-radius: 4px;
        }
        #chat::-webkit-scrollbar-thumb {
            background: #4b5563;
            border-radius: 4px;
        }
        #chat::-webkit-scrollbar-thumb:hover {
            background: #6b7280;
        }
    </style>
</head>
<body class="bg-gray-950 text-gray-100 flex items-center justify-center min-h-screen p-4">
    <div class="w-full max-w-2xl bg-gray-900 rounded-xl shadow-2xl p-6 flex flex-col h-[80vh]">
        <h1 class="text-3xl font-bold mb-4 text-center text-blue-400">MLSwarm K/V</h1>
        <p class="text-sm text-gray-400 mb-6 text-center">A simple, serverless-style chat using a K/V-JSON backend.</p>

        <!-- User and Chat ID Configuration -->
        <div class="flex flex-col md:flex-row gap-4 mb-4">
            <input type="text" id="chatIdInput" placeholder="Chat ID (e.g., 'team-a')"
                   class="bg-gray-800 text-white p-3 rounded-lg flex-1 focus:outline-none focus:ring-2 focus:ring-blue-500 transition-all">
            <input type="text" id="usernameInput" placeholder="Username"
                   class="bg-gray-800 text-white p-3 rounded-lg flex-1 focus:outline-none focus:ring-2 focus:ring-blue-500 transition-all">
        </div>

        <!-- Chat Display -->
        <div id="chatDisplay" 
             class="flex-1 bg-gray-800 overflow-y-auto p-4 rounded-lg mb-4 flex flex-col gap-3 font-mono text-sm transition-all">
            <!-- Messages will be injected here by JavaScript -->
            <div id="loadingIndicator" class="text-center text-gray-500 italic">
                Enter a Chat ID and Username to get started...
            </div>
        </div>

        <!-- Message Input -->
        <div class="flex gap-4">
            <input type="text" id="messageInput" placeholder="Type a message..."
                   class="bg-gray-800 text-white p-3 rounded-lg flex-1 focus:outline-none focus:ring-2 focus:ring-blue-500 transition-all"
                   onkeydown="if(event.key==='Enter') sendMessage()">
            <button onclick="sendMessage()"
                    class="bg-blue-600 hover:bg-blue-700 text-white font-bold p-3 rounded-lg transition-all duration-300 transform hover:scale-105">
                Send
            </button>
        </div>
    </div>

    <script>
        // Use an IIFE (Immediately Invoked Function Expression) to avoid global pollution.
        (function() {
            // --- Core Configuration and State ---
            const KV_ENDPOINT = '/kv'; // The URL for your K/V server.
            const POLL_INTERVAL = 2000; // Poll for new messages every 2 seconds.
            const MAX_MESSAGES = 100; // Keep the last 100 messages in the chat history.

            const chatDisplay = document.getElementById('chatDisplay');
            const usernameInput = document.getElementById('usernameInput');
            const chatIdInput = document.getElementById('chatIdInput');
            const messageInput = document.getElementById('messageInput');
            const loadingIndicator = document.getElementById('loadingIndicator');

            let lastMessageId = 0; // Tracks the ID of the last message received to avoid duplicates.
            let pollTimer = null; // Stores the polling timer to allow it to be cleared.
            
            // --- UI Interaction and Event Handlers ---
            chatIdInput.addEventListener('change', startChat);
            usernameInput.addEventListener('change', startChat);

            async function startChat() {
                const chatId = chatIdInput.value.trim();
                const username = usernameInput.value.trim();
                if (!chatId || !username) {
                    loadingIndicator.textContent = "Please enter both a Chat ID and a Username.";
                    return;
                }

                // If a new chat is started, reset and clear the display.
                if (pollTimer) {
                    clearTimeout(pollTimer);
                    lastMessageId = 0;
                    chatDisplay.innerHTML = '';
                    loadingIndicator.textContent = 'Loading messages...';
                }

                // Initial poll to fetch existing messages and start the polling loop.
                pollMessages(chatId);
            }
            
            async function sendMessage() {
                const chatId = chatIdInput.value.trim();
                const username = usernameInput.value.trim();
                const messageText = messageInput.value.trim();

                if (!chatId || !username || !messageText) {
                    // Don't send empty messages or if chat isn't configured.
                    return;
                }
                
                // Get current messages from the K/V store.
                const currentMessages = await getMessages(chatId);
                
                // Create the new message object.
                const newMessage = {
                    id: Date.now(), // Use a timestamp for a unique, sortable ID.
                    username: username,
                    text: messageText,
                    timestamp: new Date().toLocaleTimeString()
                };
                
                // Add the new message and trim the list to MAX_MESSAGES.
                const updatedMessages = [...currentMessages, newMessage].slice(-MAX_MESSAGES);
                
                // Save the updated list back to the K/V store.
                await saveMessages(chatId, updatedMessages);
                
                // Clear the message input box.
                messageInput.value = '';
            }
            
            // --- Core K/V-JSON Communication Functions ---
            async function getMessages(chatId) {
                try {
                    const response = await fetch(`${KV_ENDPOINT}/${chatId}`);
                    // If the key doesn't exist, the server returns 404. We return an empty array.
                    if (response.status === 404) {
                        return [];
                    }
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return await response.json();
                } catch (e) {
                    console.error('Error fetching messages:', e);
                    return [];
                }
            }
            
            async function saveMessages(chatId, messages) {
                try {
                    const response = await fetch(`${KV_ENDPOINT}/${chatId}`, {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify(messages)
                    });
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                } catch (e) {
                    console.error('Error saving messages:', e);
                }
            }

            async function pollMessages(chatId) {
                // Fetch the latest messages from the server.
                const allMessages = await getMessages(chatId);
                
                // If there are new messages, render them.
                if (allMessages.length > lastMessageId) {
                    loadingIndicator.style.display = 'none';
                    renderMessages(allMessages);
                }
                
                // Set the next poll timer.
                pollTimer = setTimeout(() => pollMessages(chatId), POLL_INTERVAL);
            }
            
            function renderMessages(messages) {
                // Clear the display for a full re-render. This is simple and works for small data.
                chatDisplay.innerHTML = '';
                
                messages.forEach(msg => {
                    // Update lastMessageId to the latest message ID
                    lastMessageId = msg.id;

                    const messageElement = document.createElement('div');
                    messageElement.className = 'flex items-baseline gap-2';
                    messageElement.innerHTML = `
                        <span class="text-blue-400 font-bold">${msg.username}:</span>
                        <span class="flex-1 text-gray-300">${msg.text}</span>
                        <span class="text-xs text-gray-500">${msg.timestamp}</span>
                    `;
                    chatDisplay.appendChild(messageElement);
                });
                
                // Auto-scroll to the bottom.
                chatDisplay.scrollTop = chatDisplay.scrollHeight;
            }
        })();
    </script>
</body>
</html>
