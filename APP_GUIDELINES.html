<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>App Guidelines</title>
    <style>
        body { margin: 0; padding: 0; background: #000; color: #0F0; font-family: "Courier New", monospace; font-size: 14px; line-height: 1.4; }
        .header { background: #0F0; color: #000; padding: 2px 5px; display: flex; justify-content: space-between; align-items: center; border-bottom: 2px solid #0F0; }
        .header-title { font-weight: bold; }
        .header-buttons { display: flex; gap: 10px; }
        .header-button { background: #C0C0C0; color: #000; border: 2px outset #FFF; padding: 1px 6px; cursor: pointer; font-family: inherit; font-size: inherit; }
        .content { padding: 10px; max-width: 80ch; margin: 0 auto; }
        .manifesto-container { max-width: 80ch; margin: 20px auto; padding: 20px; border: 2px solid #0F0; box-shadow: 0 0 10px #0F0, inset 0 0 10px #0F0; animation: flicker 1s infinite alternate; background: rgba(0, 50, 0, 0.2); overflow-x: auto; }
        @keyframes flicker { 0% { opacity: 1; } 100% { opacity: 0.98; } }
        h1, h2, h3 { color: #0FF; text-shadow: 0 0 5px #0FF; text-align: center; }
        h1 { font-size: 2em; margin-bottom: 0.5em; }
        h2 { font-size: 1.5em; margin-top: 1.5em; }
        h3 { font-size: 1.2em; text-decoration: underline; color: #FF0; }
        p { margin: 1em 0; text-align: justify; }
        pre { background: rgba(0, 0, 0, 0.5); border: 1px solid #0F0; padding: 10px; overflow-x: auto; color: #FFF; white-space: pre-wrap; word-wrap: break-word; }
        code { color: #0FF; background: #111; padding: 2px 4px; }
        ul { list-style-type: "⚡ "; margin: 1em 0; padding-left: 20px; }
        ol { margin: 1em 0; padding-left: 20px; }
        li { margin: 5px 0; }
        a { color: #00F; text-decoration: underline; }
        a:hover { background: #00F; color: #FFF; }
        hr { border: 1px dashed #0F0; margin: 2em 0; }
    </style>
</head>
<body>
    <div class="header">
        <span class="header-title">App Guidelines</span>
        <div class="header-buttons">
            <button class="header-button">_</button>
            <button class="header-button">□</button>
            <button class="header-button">X</button>
        </div>
    </div>
    <div class="content manifesto-container">
<h1>Magic Launcher Application Guidelines</h1>
<h2>Building Tools That Just Fucking Work</h2>
<h3>Core Philosophy</h3>
<p><strong>Simple enough to be wrong consistently beats complex enough to be right occasionally.</strong></p>
<p>Every Magic Launcher tool follows these principles. No exceptions. No "but what if..."</p>
<p>If you're arguing for complexity, you've already lost.</p>
<hr>
<h2>The Pillars</h2>
<h3>Speed is Life, Bloat is Death</h3>
<ul>
    <li>Sub-second startup, <50MB RAM.</li>
    <li>Every feature must justify its performance cost.</li>
</ul>
<h3>OS-Free Thinking</h3>
<ul>
    <li>Same behavior across platforms (Raspberry Pi to gaming rig).</li>
    <li>No OS-specific dependencies; use file-based configs.</li>
</ul>
<h3>Focused Functionality</h3>
<ul>
    <li>Solve one problem exceptionally.</li>
    <li>Resist feature creep; explainable in one sentence.</li>
</ul>
<h2>Technical Standards</h2>
<h3>Minimum Requirements:</h3>
<ul>
    <li>640x480 display, 32MB RAM, Python 3.6+, minimal dependencies (stdlib preferred).</li>
</ul>
<h3>Visual Design:</h3>
<ul>
    <li>CGA/EGA-inspired colors, monospace fonts, fixed grids.</li>
    <li>No animations, support 16-color terminals.</li>
</ul>
<h3>Code Principles:</h3>
<ul>
    <li>Simple, fast code (e.g., subprocess.run(path)) over clever abstractions.</li>
    <li>Fail gracefully, log quietly, prioritize keyboard navigation.</li>
</ul>
<pre><code>
File Structure:  app_name/
├── app.py        # Core logic
├── config.json   # Human-readable config
└── README.md     # One-page max
</pre>
<h2>Target Constraints</h2>
<h3>1. Line Limit: 500 Maximum, 200 Optimal</h3>
<ul>
    <li>Under 200 lines: Perfect, ship it</li>
    <li>200-300 lines: Acceptable if necessary</li>
    <li>300-500 lines: Better have a damn good reason</li>
    <li>Over 500 lines: You're building the wrong tool, or applying this to the wrong problem.</li>
</ul>
<p><strong>Why:</strong> If you can't understand the entire tool in one reading, it's too complex.</p>
<h3>2. Dependencies: Zero Default, Minimal When Necessary</h3>
<pre><code>
# GOOD
import random
import json
from pathlib import Path

# ACCEPTABLE
import tkinter  # Comes with Python

# QUESTIONABLE
import requests  # Now everyone needs pip install

# FORBIDDEN
import pandas, numpy, scipy  # This isn&#x27;t data science, it&#x27;s a dice roller
</pre>
<h3>3. Single File Deployment</h3>
<p>One <code>.py</code> file. That's it. No folders, no modules, no config files unless absolutely necessary.</p>
<p><strong>Exception:</strong> External data files (JSON) are acceptable if they're optional enhancements, not requirements.</p>
<h3>4. Instant Startup</h3>
<pre><code>
# Time from enter to result should be &lt; 1 second
$ python mltool.py --option value
[IMMEDIATE OUTPUT]
</pre>
<p>No loading bars. No splash screens. No "initializing..." messages.</p>
<p>The tool runs or it doesn't.</p>
<hr>
<h2>Design Patterns</h2>
<h3>Guide for Builders</h3>
<ul>
    <li>Design for deletion.</li>
    <li>If a component can’t be removed without surgery, it’s the wrong component.</li>
    <li>Favor small processes with clear seams, plain files over hidden state, and interfaces you can replace in an afternoon.</li>
</ul>
<p>~~Easy to delete, easy to replace~~</p>
<ul>
    <li>Measure ends, not means.</li>
    <li>Pick one metric that tracks the outcome you actually care about (e.g., time-to-success for a user task), and treat all other numbers as diagnostics, not targets.</li>
    <li>If a metric starts steering behavior away from purpose, drop it—even if it’s beautifully instrumented.</li>
</ul>
<p>~~Easy measure, easy interpret~~</p>
<ul>
    <li>Speak human, cut intermediaries.</li>
    <li>Require that designs, docs, and PR descriptions pass the “smart friend outside the team” test.</li>
    <li>Prefer mechanisms over metaphors, examples over jargon, and defaults that work without training.</li>
    <li>Every interpreter you remove returns autonomy to the people doing the work.</li>
</ul>
<p>~~The Law of Self Interest dictates the middleman places you second~~</p>
<h3>Input/Output Philosophy</h3>
<pre><code>
# CLI: Arguments in, text out
$ python mltool.py --count 5 --type basic
[RESULTS]

# GUI: Only for repeated interaction
# Never require GUI for single operations
</pre>
<h3>Error Handling</h3>
<pre><code>
# Wrong - too helpful
try:
complex_operation()
except SpecificError as e:
logger.error(f&quot;Operation failed: {e}&quot;)
suggestions = generate_suggestions(e)
print(f&quot;Try: {suggestions}&quot;)

# Right - fail fast, fail clear
try:
simple_operation()
except Exception as e:
print(f&quot;Error: {e}&quot;)
sys.exit(1)
</pre>
<h3>Data Storage</h3>
<pre><code>
# Priority order:
1. No storage (stateless)
2. Text files (grep-able)
3. JSON (human-readable)
4. SQLite (if you must)
5. Anything else (you&#x27;re overengineering)
</pre>
<hr>
<h2>The Two-File Rule</h2>
<p>Sometimes one file isn't enough. That's fine. But never more than two without serious justification.</p>
<pre><code>
# Acceptable two-file patterns:
tool.py           # The tool
tool_data.json    # Optional data

# Also acceptable:
tool.py          # CLI version
tool_gui.py      # GUI wrapper
</pre>
<h3>The GUI Split Rule</h3>
<p><strong>When GUI code exceeds 40% of your tool, split it.</strong></p>
<pre><code>
# Good candidates for splitting:
<ul>
- Battlemap generator (complex canvas drawing)
- Character sheet manager (many input fields)
- Initiative tracker (dynamic lists)

</ul>
# Keep together:
<ul>
- Dice roller (few buttons)
- NPC generator (simple output)
- Loot generator (basic display)
</ul>
</pre>
<p><strong>The Import Rule:</strong> If you split, the GUI imports the logic, never the reverse.</p>
<pre><code>
# RIGHT
# tool.py - standalone CLI tool
# tool_gui.py - imports tool.py

# WRONG
# tool_core.py - can&#x27;t run alone
# tool_cli.py - wrapper
# tool_gui.py - another wrapper
</pre>
<p><strong>The Test:</strong> Can you delete the GUI file and still have a working tool? If yes, you did it right.</p>
<hr>
<h2>Common Patterns</h2>
<h3>Random Generation</h3>
<pre><code>
# Every generator needs:
<ul>
- Predictable categories (tiers, types, levels)
- Sane defaults
- Optional complexity

</ul>
def generate(tier=&quot;basic&quot;, count=1):
# Not 47 parameters
# Not machine learning
# Just random.choice() and move on
</pre>
<h3>GUI When Necessary</h3>
<pre><code>
# Use tkinter - it&#x27;s already there
# No web servers for local tools
# No electron apps for dice rollers

import tkinter as tk
from tkinter import ttk

# Keep it simple:
# - Buttons that do things
# - Text that shows results
# - Maybe a dropdown
# That&#x27;s it.
</pre>
<h3>CLI Arguments</h3>
<pre><code>
# Good arguments:
--count     # How many
--type      # What kind
--output    # Where to save

# Bad arguments:
--config-file-path-override
--enable-extended-validation-mode
--compatibility-framework-version
</pre>
<h3>The Copy-Paste Test</h3>
<p>If you're copying code more than twice, you're doing it wrong.</p>
<pre><code>
# WRONG
handle_room_0()
handle_room_1()
handle_room_2()
# ... 47 more

# RIGHT
for i in range(50):
handle_room(i)
</pre>
<h3>The Math Not Madness Principle</h3>
<pre><code>
# WRONG - Individual handling
if id == 0: return (0, 0)
if id == 1: return (0, 1)
if id == 2: return (0, 2)

# RIGHT - Use math
return (id // width, id % width)
</pre>
<hr>
<h2>What Makes a Good ML Tool</h2>
<h3>It Solves ONE Problem</h3>
<ul>
    <li><code>MLDice</code>: Rolls dice</li>
    <li><code>MLMookLoot</code>: Generates loot</li>
    <li><code>MLBattlemap</code>: Makes a map</li>
</ul>
<p>Not: "MLGameSystem - Complete RPG Management Suite"</p>
<h3>It Works Immediately</h3>
<pre><code>
$ python mldice.py 3d6
Result: 14
</pre>
<p>No configuration. No setup. No tutorials.</p>
<h3>It's Modifiable</h3>
<p>Someone should be able to:</p>
<p>1. Open the file</p>
<p>2. Find the data arrays</p>
<p>3. Change them</p>
<p>4. Save and run</p>
<p>Without documentation. Without debugging. Without architecture diagrams.</p>
<h3>It Degrades Gracefully</h3>
<pre><code>
# If optional features fail, core still works
try:
from PIL import Image
can_export_image = True
except ImportError:
can_export_image = False

# Tool still works, just text-only
</pre>
<hr>
<h2>Anti-Patterns to Avoid</h2>
<h3>The Framework Trap</h3>
<pre><code>
# WRONG
class AbstractToolFactory:
def create_tool_instance(self):
pass

# RIGHT
def roll_dice(dice_string):
return result
</pre>
<h3>The Configuration Curse</h3>
<pre><code>
# WRONG
config = load_config(&#x27;config.yaml&#x27;)
if config[&#x27;advanced&#x27;][&#x27;options&#x27;][&#x27;dice&#x27;][&#x27;mode&#x27;] == &#x27;standard&#x27;:

# RIGHT
def roll(dice=&quot;1d6&quot;):
# Defaults work for 90% of cases
</pre>
<h3>The Modularity Mirage</h3>
<pre><code>
# WRONG
from tool.core.handlers import DiceHandler
from tool.utils.validators import validate_input
from tool.models.dice import DiceModel

# RIGHT
# It&#x27;s all in one file
# You can see everything
# You can change everything
</pre>
<hr>
<h2>Know how complicated the problem actually is.</h2>
<p>Not all problems can be solved in under 500 lines of code.</p>
<ul>
    <li>Advanced 3D rendering (Vector graphics however...)</li>
    <li>Physics Engines</li>
    <li>Scientific simulations</li>
</ul>
<h3>The questions then become:</h3>
<p>#### How can I compartmentalise each aspect of the problem?</p>
<p>#### How atomic can I make each problem?</p>
<p>1. What's the actual problem? (Not the system, the PROBLEM)</p>
<p>2. Can this be multiple simple tools instead of one complex one?</p>
<p>3. What's the smallest useful piece I can build?</p>
<p>~~99% of problems are really simple if you keep focused on the problem itself~~</p>
<hr>
<h2>Testing Philosophy</h2>
<p><strong>No unit tests.</strong></p>
<p>If the tool is simple enough, you test it by running it. If it needs unit tests, it's too complex.</p>
<pre><code>
# This is your test suite:
$ python mltool.py
$ python mltool.py --weird-input
$ python mltool.py --count 1000

# Did it crash? No? Ship it.
</pre>
<hr>
<h2>Documentation Standard</h2>
<pre><code>
#!/usr/bin/env python3
&quot;&quot;&quot;
MLToolName - Magic Launcher [Purpose]
[One line about when you&#x27;d use this]
Under [X] lines of [adjective] [noun]
&quot;&quot;&quot;

# That&#x27;s it. That&#x27;s the docs.
# The code explains itself or it&#x27;s wrong.
</pre>
<hr>
<h2>The Revolution Checklist</h2>
<p>Before releasing an ML tool, ask:</p>
<ul>
    <li>[ ] Is it under 500 lines?</li>
    <li>[ ] Can someone understand it in 5 minutes?</li>
    <li>[ ] Does it work without pip install?</li>
    <li>[ ] Does it solve ONE clear problem?</li>
    <li>[ ] Could a tired DM use it mid-session?</li>
    <li>[ ] Is it faster than doing it manually?</li>
    <li>[ ] Can someone modify it without breaking everything?</li>
</ul>
<p>If any answer is "no", it's not a Magic Launcher tool.</p>
<hr>
<h2>Remember</h2>
<p><strong>We're not building software. We're building tools.</strong></p>
<p>Tools get used. Tools get modified. Tools solve problems.</p>
<p>Software gets maintained. Software gets architected. Software gets abandoned.</p>
<p><strong>The revolution is 100 lines that replace 100,000.</strong></p>
<p>Every Magic Launcher tool is proof that the entire industry is overengineering.</p>
<p>Keep it simple. Keep it working. Keep shipping.</p>
<hr>
<p><em>"Perfection is achieved not when there is nothing more to add, but when there is nothing left to take away."</em></p>
<p>But also:</p>
<p><em>"Sometimes you need two files. That's fine. Three is pushing it."</em></p>
<hr>
<h3>Recommended Further Reading</h3>
<p>The DOCS folder has gotten quite lengthy and I admit significant portions are the WHY of things or musings on completely separate topics.</p>
<p>Key Documents I think will provide you the toolkit to create tools that bring you joy:</p>
<p>#### APP_GUIDELINES.md</p>
<p>This document was already a good start.</p>
<p>#### making<em>tools/command</em>expansion.md</p>
<p>How to use <code>$()</code> to compose tools. The forgotten Unix power that turns every CLI into a function.</p>
<p>#### making_tools/templates/</p>
<ul>
    <li><code>core.py</code> - Basic CLI template (17 lines of boilerplate)</li>
    <li><code>core<em>plus</em>gui.py</code> - CLI with optional GUI</li>
    <li><code>template.html</code> - Web interface template</li>
</ul>
<p>Start with these. Modify the <code>run()</code> function. Ship it.</p>
<p>#### Vol. 2 03 + 04</p>
<ul>
    <li>"Glyphs are magic" explains a lot about why pipes and text streams can be powerful</li>
</ul>
<p>#### Vol1. Silicon_Spring.html</p>
<p>[https://zerofuchs.co.za/manifesto/SILICONSPRING.html]</p>
<p>The aspiration. The mad dream. The philosophy behind the revolution. Read when you need motivation or context.</p>
<p>Or just hit up the webpage:</p>
<p>#### making_tools/ (folder)</p>
<p>A folder specifically earmarked for documents covering practical implementation:</p>
<ul>
    <li>Command expansion, pipes, and Unix composition patterns</li>
    <li>Cron scheduling and automation</li>
    <li>Different ways of composing MLTools to produce solutions</li>
    <li>Real-world examples and patterns</li>
</ul>
<h2>END TRANSMISSION</h2>
<p>May your tools be simple and your code be short.</p>
<p>The revolution continues.</p>
    </div>
</body>
</html>