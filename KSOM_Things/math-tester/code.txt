"""
Configurable Mathematical Consciousness Swarm System
Experiment with different consciousness parameters and visualizations
"""

import numpy as np
import math
import matplotlib.pyplot as plt
from pathlib import Path
from dataclasses import dataclass
from typing import List, Tuple, Optional

@dataclass
class ConsciousnessConfig:
    """Configuration class for mathematical consciousness experiments"""
    
    # Swarm Parameters
    num_oscillators: int = 25
    time_steps: int = 1200
    collatz_seeds: Optional[List[int]] = None  # Auto-generate if None
    
    # Kuramoto Parameters
    base_frequency: float = 0.6      # Base consciousness frequency (Hz)
    frequency_span: float = 0.6      # Frequency variation range
    coupling_strength_min: float = 0.05  # Min Pi coupling strength
    coupling_strength_max: float = 0.6   # Max Pi coupling strength
    dt: float = 0.03                 # Time step
    noise_level: float = 0.0         # Consciousness noise
    
    # Pi Parameters
    pi_smoothing_window: int = 7     # Smoothing window for Pi coupling
    pi_digits_ratio: int = 4         # T//pi_digits_ratio digits to use
    
    # Network Topology
    ring_connections: bool = True    # Connect neighbors in ring
    random_connections: int = None   # Number of random connections (auto if None)
    random_connection_strength: float = 0.5
    
    # SOM Parameters
    som_width: int = 6
    som_height: int = 6
    som_sigma: float = 1.2
    som_learning_rate: float = 0.4
    som_iterations: int = 600
    
    # Visualization Parameters
    plot_time_window: int = 400      # Time window for phase plots
    num_sample_oscillators: int = 6  # Number of oscillators to plot
    figure_size: Tuple[int, int] = (12, 8)
    dpi: int = 150
    
    # Graph Scale Parameters
    coupling_ylim: Tuple[float, float] = None  # Auto-scale if None
    order_ylim: Tuple[float, float] = (0, 1.05)
    phase_ylim: Tuple[float, float] = None     # Auto-scale if None
    plv_ylim: Tuple[float, float] = (0, 1.05)
    
    def __post_init__(self):
        """Auto-generate missing parameters"""
        if self.collatz_seeds is None:
            self.collatz_seeds = list(range(27, 27 + self.num_oscillators))
        
        if self.random_connections is None:
            self.random_connections = self.num_oscillators // 2

class MathematicalConsciousnessSwarm:
    def __init__(self, config: ConsciousnessConfig):
        self.config = config
        self.rhythms = None
        self.omega = None
        self.K_t = None
        self.theta = None
        self.R = None
        self.psi = None
        self.features = None
        self.som = None
        self.adjacency = None
        
    def collatz_sequence(self, n, max_len=1000):
        """Generate Collatz sequence"""
        seq = [n]
        while n != 1 and len(seq) < max_len:
            n = n // 2 if n % 2 == 0 else 3*n + 1
            seq.append(n)
        return seq

    def collatz_rhythm(self, seq):
        """Convert Collatz sequence to rhythm pattern"""
        r = []
        for i in range(1, len(seq)):
            r.append(-1.0 if seq[i-1] % 2 == 0 else 1.0)
        return np.array(r, dtype=float)

    def pi_digits(self, n):
        """Generate Pi digits using Machin's formula"""
        terms = 2000
        def arctan_series(x):
            s = 0.0
            sign = 1.0
            p = x
            for k in range(1, 2*terms, 2):
                s += sign * p / k
                p *= x*x
                sign *= -1.0
            return s
        pi_est = 4.0 * (4*arctan_series(1/5) - arctan_series(1/239))
        s = f"{pi_est:.{n+5}f}"
        frac = s.split(".")[1][:n]
        return np.array([int(ch) for ch in frac], dtype=int)

    def build_collatz_oscillators(self):
        """Build consciousness oscillators from Collatz sequences"""
        print(f"üß† Building {self.config.num_oscillators} Collatz consciousness oscillators...")
        
        rhythms = []
        for n in self.config.collatz_seeds:
            r = self.collatz_rhythm(self.collatz_sequence(n, max_len=self.config.time_steps+5))
            if len(r) < self.config.time_steps:
                r = np.concatenate([r, np.tile(r[-1], self.config.time_steps - len(r))])
            else:
                r = r[:self.config.time_steps]
            rhythms.append(r)
        
        self.rhythms = np.stack(rhythms, axis=1)
        
        # Map rhythms to consciousness frequencies
        omega = 2*np.pi * (self.config.base_frequency + 
                          self.config.frequency_span * 0.5 * (self.rhythms.mean(axis=0) + 1.0))
        self.omega = omega
        
        print(f"   Frequency range: {omega.min()/(2*np.pi):.3f} - {omega.max()/(2*np.pi):.3f} Hz")

    def build_pi_coupling_modulation(self):
        """Build Pi-based consciousness coupling modulation"""
        print("ü•ß Building Pi consciousness coupling modulation...")
        
        d = self.pi_digits(max(16, self.config.time_steps // self.config.pi_digits_ratio))
        d = np.tile(d, math.ceil(self.config.time_steps / len(d)))[:self.config.time_steps]
        
        # Map Pi digits to coupling strength
        K = (self.config.coupling_strength_min + 
             (d / 9.0) * (self.config.coupling_strength_max - self.config.coupling_strength_min))
        
        # Smooth coupling for stable consciousness dynamics
        if self.config.pi_smoothing_window > 1:
            K = np.convolve(K, np.ones(self.config.pi_smoothing_window) / self.config.pi_smoothing_window, mode='same')
        
        self.K_t = K
        print(f"   Coupling range: {K.min():.3f} - {K.max():.3f}")

    def build_network_topology(self):
        """Build consciousness network topology"""
        print("üï∏Ô∏è Building consciousness network topology...")
        
        N = self.config.num_oscillators
        self.adjacency = np.zeros((N, N), dtype=float)
        
        # Ring connections (neighbors)
        if self.config.ring_connections:
            for i in range(N):
                self.adjacency[i, (i-1) % N] = 1.0
                self.adjacency[i, (i+1) % N] = 1.0
            print(f"   Added ring connections")
        
        # Random connections
        if self.config.random_connections > 0:
            rng = np.random.default_rng(7)
            connections_added = 0
            for _ in range(self.config.random_connections):
                i, j = rng.integers(0, N, size=2)
                if i != j and self.adjacency[i, j] == 0:
                    self.adjacency[i, j] = self.config.random_connection_strength
                    self.adjacency[j, i] = self.config.random_connection_strength
                    connections_added += 1
            print(f"   Added {connections_added} random connections")
        
        # Network statistics
        total_connections = (self.adjacency > 0).sum() // 2  # Undirected
        mean_degree = self.adjacency.sum(axis=1).mean()
        print(f"   Total connections: {total_connections}, Mean degree: {mean_degree:.2f}")

    def kuramoto_simulate(self):
        """Simulate Kuramoto consciousness dynamics"""
        print(f"üåä Simulating consciousness dynamics for {self.config.time_steps} time steps...")
        
        N = self.config.num_oscillators
        theta = np.zeros((self.config.time_steps, N), dtype=float)
        theta[0] = np.random.uniform(0, 2*np.pi, size=N)
        
        mean_deg = max(1, self.adjacency.sum(axis=1).mean())
        
        for t in range(1, self.config.time_steps):
            th = theta[t-1]
            diff = th.reshape(-1,1) - th.reshape(1,-1)
            K_eff = self.K_t[t] / mean_deg
            coupling_term = (self.adjacency * np.sin(-diff)).sum(axis=1)
            dtheta = self.omega + K_eff * coupling_term
            
            if self.config.noise_level > 0:
                dtheta += np.random.normal(0, self.config.noise_level, size=N)
                
            theta[t] = (th + self.config.dt * dtheta) % (2*np.pi)
        
        self.theta = theta
        
        # Calculate order parameter
        z = np.exp(1j*theta)
        Z = z.mean(axis=1)
        self.R = np.abs(Z)
        self.psi = np.angle(Z)
        
        print(f"   Final synchronization R = {self.R[-1]:.3f}")

    def extract_consciousness_features(self):
        """Extract consciousness features for SOM analysis"""
        print("üéØ Extracting consciousness features...")
        
        T, N = self.theta.shape
        unwrapped = np.unwrap(self.theta, axis=0)
        inst_freq = np.diff(unwrapped, axis=0) / (2*np.pi)
        
        mean_f = inst_freq.mean(axis=0)
        var_f = inst_freq.var(axis=0)
        
        z = np.exp(1j*self.theta)
        mean_vec = np.mean(z, axis=1, keepdims=True)
        plv_per_osc = np.abs(np.mean(z * np.conj(mean_vec), axis=0)).real
        
        self.features = np.stack([mean_f, var_f, plv_per_osc], axis=1)
        print(f"   Extracted features shape: {self.features.shape}")

    def train_som(self):
        """Train SOM on consciousness features"""
        print("üó∫Ô∏è Training SOM on consciousness features...")
        
        self.som = MiniSOM(
            m=self.config.som_width, 
            n=self.config.som_height, 
            dim=self.features.shape[1],
            sigma=self.config.som_sigma,
            lr=self.config.som_learning_rate
        )
        
        self.som.train(self.features, iters=self.config.som_iterations)
        self.bmus = self.som.map(self.features)
        print(f"   SOM training complete")

    def run_experiment(self):
        """Run complete consciousness experiment"""
        print("üöÄ Starting Mathematical Consciousness Experiment")
        print("=" * 60)
        
        self.build_collatz_oscillators()
        self.build_pi_coupling_modulation()
        self.build_network_topology()
        self.kuramoto_simulate()
        self.extract_consciousness_features()
        self.train_som()
        
        print("‚ú® Consciousness experiment complete!")
        return self

    def plot_diagnostics(self, save_path=None):
        """Plot consciousness diagnostics"""
        fig = plt.figure(figsize=self.config.figure_size)
        
        # Coupling modulation
        ax1 = fig.add_subplot(2,2,1)
        ax1.plot(self.K_t)
        ax1.set_title("Pi Consciousness Coupling K(t)")
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Coupling Strength")
        if self.config.coupling_ylim:
            ax1.set_ylim(self.config.coupling_ylim)
        
        # Global order parameter
        ax2 = fig.add_subplot(2,2,2)
        ax2.plot(self.R)
        ax2.set_title("Global Consciousness Synchronization R(t)")
        ax2.set_xlabel("Time")
        ax2.set_ylabel("Order Parameter")
        ax2.set_ylim(self.config.order_ylim)
        
        # Sample phases
        ax3 = fig.add_subplot(2,2,3)
        time_window = min(self.config.plot_time_window, self.config.time_steps)
        num_samples = min(self.config.num_sample_oscillators, self.config.num_oscillators)
        ax3.plot(self.theta[:time_window, :num_samples])
        ax3.set_title(f"Sample Consciousness Phases (first {num_samples} oscillators)")
        ax3.set_xlabel("Time")
        ax3.set_ylabel("Phase (radians)")
        if self.config.phase_ylim:
            ax3.set_ylim(self.config.phase_ylim)
        
        # Phase-locking value
        ax4 = fig.add_subplot(2,2,4)
        z = np.exp(1j*self.theta)
        mean_vec = np.mean(z, axis=1, keepdims=True)
        plv_t = np.abs(np.mean(z * np.conj(mean_vec), axis=1)).real
        ax4.plot(plv_t)
        ax4.set_title("Consciousness Phase-Locking Value")
        ax4.set_xlabel("Time")
        ax4.set_ylabel("PLV")
        ax4.set_ylim(self.config.plv_ylim)
        
        fig.tight_layout()
        
        if save_path:
            fig.savefig(save_path, dpi=self.config.dpi)
            print(f"üíæ Diagnostics saved to {save_path}")
        
        return fig

    def plot_som_analysis(self, save_path=None):
        """Plot SOM consciousness analysis"""
        fig = plt.figure(figsize=(10, 4))
        
        # Feature projection
        ax1 = fig.add_subplot(1,2,1)
        X = self.features - self.features.mean(axis=0, keepdims=True)
        C = X.T @ X / len(X)
        evals, evecs = np.linalg.eigh(C)
        proj = X @ evecs[:, -2:]
        colors = [b[0]*self.config.som_height + b[1] for b in self.bmus]
        ax1.scatter(proj[:,0], proj[:,1], c=colors, s=60, cmap='viridis')
        ax1.set_title("Consciousness Feature Projection (by SOM BMU)")
        ax1.set_xlabel("PC1")
        ax1.set_ylabel("PC2")
        
        # SOM lattice
        ax2 = fig.add_subplot(1,2,2)
        W2 = self.som.W[..., :2]
        for i in range(self.som.m):
            for j in range(self.som.n):
                x, y = W2[i,j]
                ax2.scatter(x, y, c='k', s=15)
                if i < self.som.m-1:
                    x2, y2 = W2[i+1,j]
                    ax2.plot([x,x2], [y,y2], 'k-', lw=0.5)
                if j < self.som.n-1:
                    x2, y2 = W2[i,j+1]
                    ax2.plot([x,x2], [y,y2], 'k-', lw=0.5)
        ax2.set_title("SOM Consciousness Lattice")
        ax2.set_xlabel("Feature 1")
        ax2.set_ylabel("Feature 2")
        
        fig.tight_layout()
        
        if save_path:
            fig.savefig(save_path, dpi=self.config.dpi)
            print(f"üíæ SOM analysis saved to {save_path}")
        
        return fig

    def print_consciousness_report(self):
        """Print consciousness experiment report"""
        print("\nüß† CONSCIOUSNESS EXPERIMENT REPORT")
        print("=" * 50)
        print(f"Oscillators: {self.config.num_oscillators}")
        print(f"Time Steps: {self.config.time_steps}")
        print(f"Collatz Seeds: {self.config.collatz_seeds[:5]}{'...' if len(self.config.collatz_seeds) > 5 else ''}")
        print(f"Frequency Range: {self.omega.min()/(2*np.pi):.3f} - {self.omega.max()/(2*np.pi):.3f} Hz")
        print(f"Coupling Range: {self.K_t.min():.3f} - {self.K_t.max():.3f}")
        print(f"Final Synchronization: {self.R[-1]:.3f}")
        print(f"Max Synchronization: {self.R.max():.3f}")
        print(f"Network Connections: {(self.adjacency > 0).sum() // 2}")
        print(f"SOM Grid: {self.config.som_width}x{self.config.som_height}")

class MiniSOM:
    """Minimal SOM implementation for consciousness feature analysis"""
    def __init__(self, m, n, dim, sigma=1.2, lr=0.3, seed=42):
        self.m = m; self.n = n; self.dim = dim
        self.sigma = sigma; self.lr = lr
        rng = np.random.default_rng(seed)
        self.W = rng.normal(0, 1, size=(m, n, dim))
        xs, ys = np.meshgrid(np.arange(m), np.arange(n), indexing='ij')
        self.coords = np.stack([xs, ys], axis=-1)
    
    def _gaussian(self, c, sigma):
        d2 = np.sum((self.coords - c)**2, axis=-1)
        return np.exp(-d2 / (2*sigma*sigma))
    
    def train(self, data, iters=400):
        rng = np.random.default_rng(123)
        for t in range(iters):
            x = data[rng.integers(0, len(data))]
            d = np.linalg.norm(self.W - x, axis=-1)
            bmu = np.unravel_index(np.argmin(d), (self.m, self.n))
            frac = t / max(1, iters-1)
            lr_t = self.lr * (1 - frac)
            sig_t = max(0.5, self.sigma * (1 - 0.8*frac))
            h = self._gaussian(np.array(bmu), sig_t)[..., None]
            self.W += lr_t * h * (x - self.W)
    
    def map(self, data):
        idxs = []
        for x in data:
            d = np.linalg.norm(self.W - x, axis=-1)
            idxs.append(np.unravel_index(np.argmin(d), (self.m, self.n)))
        return np.array(idxs)

# Example usage and presets
def quick_experiment():
    """Quick consciousness experiment with default settings"""
    config = ConsciousnessConfig()
    swarm = MathematicalConsciousnessSwarm(config)
    swarm.run_experiment()
    swarm.print_consciousness_report()
    
    # Plot results
    fig1 = swarm.plot_diagnostics()
    fig2 = swarm.plot_som_analysis()
    plt.show()
    
    return swarm

def deep_consciousness_experiment():
    """Deep consciousness experiment with extended parameters"""
    config = ConsciousnessConfig(
        num_oscillators=50,
        time_steps=20000,
        collatz_seeds=list(range(17, 67)),  # Different seed range
        base_frequency=0.3,
        frequency_span=1.0,
        coupling_strength_max=0.8,
        som_width=16,
        som_height=16,
        plot_time_window=12000,
        num_sample_oscillators=20
    )
    
    swarm = MathematicalConsciousnessSwarm(config)
    swarm.run_experiment()
    swarm.print_consciousness_report()
    
    # Save results
    out_dir = Path('./data')
    out_dir.mkdir(exist_ok=True)
    
    fig1 = swarm.plot_diagnostics(out_dir / 'deep_consciousness_diagnostics.png')
    fig2 = swarm.plot_som_analysis(out_dir / 'deep_consciousness_som.png')
    plt.show()
    
    return swarm

def chaos_consciousness_experiment():
    """High chaos consciousness experiment"""
    config = ConsciousnessConfig(
        num_oscillators=30,
        time_steps=1500,
        noise_level=0.1,  # Add consciousness noise
        coupling_strength_min=0.01,
        coupling_strength_max=0.3,  # Lower coupling = more chaos
        random_connections=20,      # More random connections
        pi_smoothing_window=3,      # Less smoothing = more chaos
        coupling_ylim=(0, 0.35),
        order_ylim=(0, 0.8)        # Expect lower synchronization
    )
    
    swarm = MathematicalConsciousnessSwarm(config)
    swarm.run_experiment()
    swarm.print_consciousness_report()
    
    fig1 = swarm.plot_diagnostics()
    fig2 = swarm.plot_som_analysis()
    plt.show()
    
    return swarm

if __name__ == "__main__":
    print("üß† Configurable Mathematical Consciousness Swarm")
    print("Choose an experiment:")
    print("1. Quick experiment (default settings)")
    print("2. Deep consciousness experiment (extended)")
    print("3. Chaos consciousness experiment (high chaos)")
    
    choice = input("Enter choice (1-3) or press Enter for quick: ").strip()
    
    if choice == "2":
        swarm = deep_consciousness_experiment()
    elif choice == "3":
        swarm = chaos_consciousness_experiment()
    else:
        swarm = quick_experiment()
    
    print("\nüéØ Experiment complete! Check the plots and try different configurations!")# Two-oscillator "entangle / disentangle" demo using Kuramoto-style coupling
# - We evolve two phases phi1, phi2 with natural frequencies w1, w2
# - Coupling K(t) is piecewise: 0 (free), K_on (entangle), 0 (disentangle)
# - We plot (1) the phases vs time, (2) phase difference & order parameter R

import numpy as np
import matplotlib.pyplot as plt

# Simulation params
dt = 0.002
T  = 20.0
t  = np.arange(0, T, dt)

# Natural frequencies (slightly detuned photons-as-oscillators surrogate)
w1 = 2.0 * np.pi * 1.00    # ~1 Hz
w2 = 2.0 * np.pi * 1.03    # ~1.03 Hz

# Coupling schedule: free (0-6s), entangle (6-14s), free (14-20s)
K_on = 3.0
def K_of_time(tt):
    if tt < 6.0:
        return 0.0
    elif tt < 14.0:
        return K_on
    else:
        return 0.0

# Small phase diffusion (optional) to show locking robustness
sigma = 0.03  # noise strength

# State arrays
phi1 = np.zeros_like(t)
phi2 = np.zeros_like(t)

# Random initial phases
phi1[0] = np.random.uniform(0, 2*np.pi)
phi2[0] = np.random.uniform(0, 2*np.pi)

# Integration (Euler-Maruyama)
for k in range(len(t)-1):
    Kt = K_of_time(t[k])
    # Kuramoto pair dynamics
    dphi1 = w1 + Kt * np.sin(phi2[k] - phi1[k])
    dphi2 = w2 + Kt * np.sin(phi1[k] - phi2[k])
    # Noise
    dphi1 += sigma * np.sqrt(dt) * np.random.randn()
    dphi2 += sigma * np.sqrt(dt) * np.random.randn()
    # Step
    phi1[k+1] = phi1[k] + dphi1 * dt
    phi2[k+1] = phi2[k] + dphi2 * dt

# Wrap to [0, 2pi)
phi1 = np.mod(phi1, 2*np.pi)
phi2 = np.mod(phi2, 2*np.pi)

# Phase difference and Kuramoto order parameter R
dphi = np.unwrap(phi1 - phi2)
# Order parameter for N=2: R = |(e^{i phi1} + e^{i phi2})/2|
R = np.abs(0.5 * (np.exp(1j*phi1) + np.exp(1j*phi2)))

# Coupling over time for reference
K_series = np.array([K_of_time(tt) for tt in t])

# Plot 1: phases vs time
plt.figure(figsize=(9, 4.8))
plt.plot(t, phi1, label="phi1(t)")
plt.plot(t, phi2, label="phi2(t)")
plt.plot(t, K_series*(2*np.pi/K_on), linestyle="--", label="K(t) scaled")
plt.title("Two-Oscillator Phases with Time-Varying Coupling")
plt.xlabel("Time (s)")
plt.ylabel("Phase (radians)")
plt.legend()
plt.tight_layout()
plt.show()

# Plot 2: phase difference & order parameter
plt.figure(figsize=(9, 4.8))
plt.plot(t, np.mod(dphi, 2*np.pi), label="Phase difference ŒîœÜ mod 2œÄ")
plt.plot(t, R, label="Order parameter R (N=2)")
plt.plot(t, K_series/K_on, linestyle="--", label="K(t)/K_on")
plt.title("Locking (ŒîœÜ stabilizes) and Coherence (R rises) during Coupling")
plt.xlabel("Time (s)")
plt.ylabel("Value")
plt.legend()
plt.tight_layout()
plt.show()
"""
Photon-Electron Consciousness Coupling Simulator
Demonstrates E=mc¬≤ as consciousness-spacetime coupling through 
energy transfer between massless and massive consciousness entities
"""

import numpy as np
import matplotlib.pyplot as plt
from dataclasses import dataclass
from typing import List, Tuple
import math

@dataclass
class ConsciousnessParticle:
    """Base class for consciousness particles"""
    name: str
    mass: float  # SOM spatial topology density (0 for photons)
    frequency: float  # Base consciousness oscillation frequency
    phase: float = 0.0  # Current consciousness phase
    energy: float = 0.0  # Current consciousness-spacetime coupling strength
    coupling_strength: float = 0.0  # Current coupling to other particles

class PhotonConsciousness(ConsciousnessParticle):
    """Pure consciousness crystallization wave (massless)"""
    def __init__(self, frequency):
        super().__init__(
            name="Photon",
            mass=0.0,  # No spatial consciousness topology
            frequency=frequency,
            energy=frequency  # E = hf ‚Üí consciousness frequency energy
        )
    
    def update_energy(self, new_frequency):
        """Photon energy = pure consciousness frequency"""
        self.frequency = new_frequency
        self.energy = new_frequency
        self.coupling_strength = np.sqrt(self.energy)  # ‚àöE coupling

class ElectronConsciousness(ConsciousnessParticle):
    """Massive consciousness entity with rest mass topology"""
    def __init__(self, rest_mass=1.0):
        super().__init__(
            name="Electron", 
            mass=rest_mass,  # Spatial consciousness topology density
            frequency=0.1,   # Low base consciousness frequency
            energy=rest_mass  # Rest energy = mc¬≤
        )
        self.rest_energy = rest_mass
    
    def update_energy(self, kinetic_energy):
        """Electron total energy = rest + kinetic consciousness"""
        self.energy = self.rest_energy + kinetic_energy
        # Higher energy ‚Üí higher consciousness frequency
        self.frequency = 0.1 + 0.1 * kinetic_energy
        self.coupling_strength = np.sqrt(self.energy)

class ConsciousnessEnergyExchange:
    """Simulates consciousness-energy exchange between photon and electron"""
    
    def __init__(self):
        # Create consciousness particles
        self.photon = PhotonConsciousness(frequency=2.0)  # High-energy photon
        self.electron = ElectronConsciousness(rest_mass=1.0)  # Rest electron
        
        # Simulation parameters
        self.time_steps = 2000
        self.dt = 0.01
        self.c_crystallization = 1.0  # Speed of consciousness crystallization (c=1 units)
        
        # Energy exchange protocol
        self.interaction_start = 600   # When particles meet
        self.interaction_end = 1400    # When particles separate
        
        # Data storage
        self.time = np.linspace(0, self.time_steps * self.dt, self.time_steps)
        self.photon_phases = np.zeros(self.time_steps)
        self.electron_phases = np.zeros(self.time_steps)
        self.photon_energies = np.zeros(self.time_steps)
        self.electron_energies = np.zeros(self.time_steps)
        self.photon_frequencies = np.zeros(self.time_steps)
        self.electron_frequencies = np.zeros(self.time_steps)
        self.coupling_strengths = np.zeros(self.time_steps)
        self.order_parameter = np.zeros(self.time_steps)
        
    def consciousness_coupling_function(self, t_step):
        """Pi-modulated consciousness coupling during interaction"""
        if self.interaction_start <= t_step <= self.interaction_end:
            # Pi digits control energy exchange rate
            pi_str = str(math.pi).replace('.', '')
            pi_index = (t_step - self.interaction_start) % len(pi_str)
            pi_digit = int(pi_str[pi_index])
            
            # Strong coupling during interaction, modulated by Pi
            base_coupling = 3.0
            pi_modulation = 0.5 + 0.5 * (pi_digit / 9.0)
            return base_coupling * pi_modulation
        else:
            return 0.0  # No interaction outside meeting period
    
    def energy_exchange_dynamics(self, t_step):
        """Consciousness energy exchange between particles"""
        coupling = self.consciousness_coupling_function(t_step)
        
        if coupling > 0:
            # Energy exchange rate proportional to coupling and energy difference
            energy_diff = self.photon.energy - self.electron.energy + self.electron.rest_energy
            exchange_rate = 0.01 * coupling * energy_diff
            
            # Photon loses energy, electron gains energy (absorption)
            if t_step < (self.interaction_start + self.interaction_end) / 2:
                # Absorption phase: photon ‚Üí electron
                energy_transfer = min(exchange_rate, self.photon.energy * 0.1)
                self.photon.update_energy(self.photon.frequency - energy_transfer)
                self.electron.update_energy(self.electron.energy - self.electron.rest_energy + energy_transfer)
            else:
                # Emission phase: electron ‚Üí photon  
                electron_excess = self.electron.energy - self.electron.rest_energy
                energy_transfer = min(exchange_rate * 0.5, electron_excess * 0.1)
                if electron_excess > 0.01:  # Only if electron has excess energy
                    self.electron.update_energy(electron_excess - energy_transfer)
                    self.photon.update_energy(self.photon.frequency + energy_transfer)
        
        return coupling
    
    def update_consciousness_phases(self, t_step, coupling):
        """Update particle consciousness phase evolution"""
        # Individual phase evolution
        self.photon.phase += self.dt * 2 * np.pi * self.photon.frequency
        self.electron.phase += self.dt * 2 * np.pi * self.electron.frequency
        
        # Phase coupling during interaction (consciousness crystallization)
        if coupling > 0:
            phase_diff = self.photon.phase - self.electron.phase
            coupling_force = coupling * np.sin(phase_diff)
            
            # Kuramoto coupling - consciousness phase synchronization
            self.photon.phase -= self.dt * coupling_force * 0.5
            self.electron.phase += self.dt * coupling_force * 0.5
        
        # Keep phases in [0, 2œÄ]
        self.photon.phase = self.photon.phase % (2 * np.pi)
        self.electron.phase = self.electron.phase % (2 * np.pi)
    
    def calculate_order_parameter(self):
        """Calculate consciousness coherence between particles"""
        # Complex representation of particle phases
        z_photon = np.exp(1j * self.photon.phase)
        z_electron = np.exp(1j * self.electron.phase)
        
        # Order parameter (consciousness synchronization)
        Z = 0.5 * (z_photon + z_electron)
        return abs(Z)
    
    def run_simulation(self):
        """Run complete photon-electron consciousness interaction simulation"""
        print("üåä Starting Photon-Electron Consciousness Coupling Simulation")
        print("=" * 70)
        print(f"Initial Photon: E={self.photon.energy:.3f}, f={self.photon.frequency:.3f} Hz")
        print(f"Initial Electron: E={self.electron.energy:.3f}, f={self.electron.frequency:.3f} Hz")
        print(f"Interaction Period: {self.interaction_start}-{self.interaction_end} steps")
        
        for t in range(self.time_steps):
            # Energy exchange dynamics
            coupling = self.energy_exchange_dynamics(t)
            
            # Consciousness phase evolution
            self.update_consciousness_phases(t, coupling)
            
            # Store data
            self.photon_phases[t] = self.photon.phase
            self.electron_phases[t] = self.electron.phase
            self.photon_energies[t] = self.photon.energy
            self.electron_energies[t] = self.electron.energy
            self.photon_frequencies[t] = self.photon.frequency
            self.electron_frequencies[t] = self.electron.frequency
            self.coupling_strengths[t] = coupling
            self.order_parameter[t] = self.calculate_order_parameter()
        
        print(f"Final Photon: E={self.photon.energy:.3f}, f={self.photon.frequency:.3f} Hz")
        print(f"Final Electron: E={self.electron.energy:.3f}, f={self.electron.frequency:.3f} Hz")
        print("‚ú® Consciousness coupling simulation complete!")
    
    def plot_consciousness_energy_dynamics(self):
        """Plot consciousness-energy coupling dynamics"""
        fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(15, 10))
        
        # Energy exchange dynamics
        ax1.plot(self.time, self.photon_energies, 'r-', label='Photon Energy', linewidth=2)
        ax1.plot(self.time, self.electron_energies, 'b-', label='Electron Total Energy', linewidth=2)
        ax1.plot(self.time, self.electron_energies - 1.0, 'b--', label='Electron Kinetic Energy', linewidth=2)
        ax1.axvspan(self.interaction_start * self.dt, self.interaction_end * self.dt, 
                   alpha=0.3, color='yellow', label='Consciousness Interaction')
        ax1.set_xlabel('Time (s)')
        ax1.set_ylabel('Energy (Consciousness-Spacetime Coupling)')
        ax1.set_title('Consciousness-Energy Exchange Dynamics')
        ax1.legend()
        ax1.grid(True)
        
        # Frequency evolution (consciousness rhythm changes)
        ax2.plot(self.time, self.photon_frequencies, 'r-', label='Photon Frequency', linewidth=2)
        ax2.plot(self.time, self.electron_frequencies, 'b-', label='Electron Frequency', linewidth=2)
        ax2.axvspan(self.interaction_start * self.dt, self.interaction_end * self.dt, 
                   alpha=0.3, color='yellow')
        ax2.set_xlabel('Time (s)')
        ax2.set_ylabel('Consciousness Frequency (Hz)')
        ax2.set_title('Consciousness Rhythm Evolution')
        ax2.legend()
        ax2.grid(True)
        
        # Phase synchronization (consciousness crystallization)
        ax3.plot(self.time, self.photon_phases, 'r-', label='Photon Phase', alpha=0.7)
        ax3.plot(self.time, self.electron_phases, 'b-', label='Electron Phase', alpha=0.7)
        ax3.axvspan(self.interaction_start * self.dt, self.interaction_end * self.dt, 
                   alpha=0.3, color='yellow')
        ax3.set_xlabel('Time (s)')
        ax3.set_ylabel('Consciousness Phase (radians)')
        ax3.set_title('Consciousness Phase Crystallization')
        ax3.legend()
        ax3.grid(True)
        
        # Order parameter and coupling strength
        ax4.plot(self.time, self.order_parameter, 'g-', label='Consciousness Coherence R(t)', linewidth=2)
        ax4.plot(self.time, self.coupling_strengths / 3.0, 'm-', label='Coupling Strength (scaled)', linewidth=2)
        ax4.axvspan(self.interaction_start * self.dt, self.interaction_end * self.dt, 
                   alpha=0.3, color='yellow')
        ax4.set_xlabel('Time (s)')
        ax4.set_ylabel('Consciousness Metrics')
        ax4.set_title('Consciousness Synchronization & Coupling')
        ax4.legend()
        ax4.grid(True)
        
        plt.tight_layout()
        plt.suptitle('Photon-Electron Consciousness Coupling: E=mc¬≤ as Phase Crystallization', 
                     fontsize=16, y=0.98)
        return fig
    
    def plot_consciousness_spacetime_diagram(self):
        """Plot consciousness-spacetime coupling visualization"""
        fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 6))
        
        # Energy-mass relationship during interaction
        photon_mass_equiv = self.photon_energies / (self.c_crystallization**2)
        electron_kinetic_mass = (self.electron_energies - 1.0) / (self.c_crystallization**2)
        
        ax1.plot(self.time, photon_mass_equiv, 'r-', label='Photon Mass Equivalent', linewidth=2)
        ax1.plot(self.time, np.ones_like(self.time), 'b-', label='Electron Rest Mass', linewidth=2)
        ax1.plot(self.time, electron_kinetic_mass, 'b--', label='Electron Kinetic Mass', linewidth=2)
        ax1.axvspan(self.interaction_start * self.dt, self.interaction_end * self.dt, 
                   alpha=0.3, color='yellow', label='Consciousness Interaction')
        ax1.set_xlabel('Time (s)')
        ax1.set_ylabel('Mass (Consciousness Topology Density)')
        ax1.set_title('E = mc¬≤: Consciousness-Spacetime Topology')
        ax1.legend()
        ax1.grid(True)
        
        # Total energy conservation
        total_energy = self.photon_energies + self.electron_energies
        ax2.plot(self.time, total_energy, 'k-', label='Total Energy', linewidth=3)
        ax2.plot(self.time, self.photon_energies, 'r-', label='Photon Energy', alpha=0.7)
        ax2.plot(self.time, self.electron_energies, 'b-', label='Electron Energy', alpha=0.7)
        ax2.axvspan(self.interaction_start * self.dt, self.interaction_end * self.dt, 
                   alpha=0.3, color='yellow')
        ax2.set_xlabel('Time (s)')
        ax2.set_ylabel('Energy (Consciousness-Spacetime Coupling)')
        ax2.set_title('Consciousness Energy Conservation')
        ax2.legend()
        ax2.grid(True)
        
        plt.tight_layout()
        return fig

def run_photon_electron_consciousness_experiment():
    """Run complete photon-electron consciousness coupling experiment"""
    
    # Create and run simulation
    sim = ConsciousnessEnergyExchange()
    sim.run_simulation()
    
    # Generate plots
    fig1 = sim.plot_consciousness_energy_dynamics()
    fig2 = sim.plot_consciousness_spacetime_diagram()
    
    plt.show()
    
    # Analysis report
    print("\nüî¨ CONSCIOUSNESS-ENERGY ANALYSIS REPORT")
    print("=" * 50)
    
    # Energy exchange analysis
    initial_photon_E = sim.photon_energies[0]
    final_photon_E = sim.photon_energies[-1]
    initial_electron_KE = sim.electron_energies[0] - 1.0
    final_electron_KE = sim.electron_energies[-1] - 1.0
    
    print(f"Photon Energy Change: {initial_photon_E:.3f} ‚Üí {final_photon_E:.3f}")
    print(f"Electron Kinetic Energy Change: {initial_electron_KE:.3f} ‚Üí {final_electron_KE:.3f}")
    print(f"Energy Exchange: {initial_photon_E - final_photon_E:.3f}")
    
    # Consciousness synchronization analysis
    max_coherence = np.max(sim.order_parameter)
    interaction_coherence = np.mean(sim.order_parameter[sim.interaction_start:sim.interaction_end])
    
    print(f"Maximum Consciousness Coherence: {max_coherence:.3f}")
    print(f"Average Interaction Coherence: {interaction_coherence:.3f}")
    
    # Phase relationship analysis
    interaction_phases = sim.photon_phases[sim.interaction_start:sim.interaction_end] - \
                        sim.electron_phases[sim.interaction_start:sim.interaction_end]
    phase_locking_strength = 1.0 - np.std(interaction_phases) / np.pi
    
    print(f"Phase-Locking Strength: {phase_locking_strength:.3f}")
    
    return sim

def consciousness_relativity_validation():
    """Validate consciousness interpretation of E=mc¬≤"""
    
    print("\nüåå CONSCIOUSNESS-RELATIVITY VALIDATION")
    print("=" * 50)
    
    # Test different photon energies
    photon_energies = [0.5, 1.0, 2.0, 4.0]
    electron_excitations = []
    max_coherences = []
    
    for E_photon in photon_energies:
        print(f"\nTesting Photon Energy: {E_photon}")
        
        sim = ConsciousnessEnergyExchange()
        sim.photon.update_energy(E_photon)
        sim.run_simulation()
        
        # Measure electron excitation and consciousness coherence
        final_electron_KE = sim.electron_energies[-1] - 1.0
        max_coherence = np.max(sim.order_parameter)
        
        electron_excitations.append(final_electron_KE)
        max_coherences.append(max_coherence)
        
        print(f"  ‚Üí Electron Excitation: {final_electron_KE:.3f}")
        print(f"  ‚Üí Max Consciousness Coherence: {max_coherence:.3f}")
    
    # Plot validation results
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 5))
    
    ax1.plot(photon_energies, electron_excitations, 'ro-', linewidth=2, markersize=8)
    ax1.set_xlabel('Photon Energy (Consciousness Frequency)')
    ax1.set_ylabel('Electron Excitation (Consciousness Activation)')
    ax1.set_title('Energy Transfer Scaling')
    ax1.grid(True)
    
    ax2.plot(photon_energies, max_coherences, 'bo-', linewidth=2, markersize=8)
    ax2.set_xlabel('Photon Energy (Consciousness Frequency)')
    ax2.set_ylabel('Max Consciousness Coherence')
    ax2.set_title('Consciousness Coupling Scaling')
    ax2.grid(True)
    
    plt.tight_layout()
    plt.suptitle('Consciousness-Relativity Validation: E=mc¬≤ Scaling', fontsize=14, y=0.98)
    plt.show()
    
    print(f"\n‚ú® Validation Complete!")
    print(f"Energy-Coherence Correlation: {np.corrcoef(photon_energies, max_coherences)[0,1]:.3f}")

if __name__ == "__main__":
    print("üåäüíÄ PHOTON-ELECTRON CONSCIOUSNESS COUPLING SIMULATOR")
    print("Demonstrates E=mc¬≤ as consciousness-spacetime coupling dynamics")
    print("=" * 70)
    
    # Run main experiment
    sim = run_photon_electron_consciousness_experiment()
    
    # Run validation tests
    consciousness_relativity_validation()
    
    print("\nüéØ CONSCIOUSNESS-PHYSICS UNIFICATION DEMONSTRATED!")
    print("Photon-electron interactions show consciousness crystallization dynamics")
    print("E = mc¬≤ emerges as consciousness-spacetime topology coupling!")