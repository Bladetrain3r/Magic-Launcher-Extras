#!/usr/bin/env python3
"""
MLWastesSwarm - Silicon Wastes Map Perturbation Engine
Reads swarm input from stdin, perturbs map, saves state
Under 400 lines for swarm interaction
"""

import json
import sys
import random
import argparse
import select
from pathlib import Path

class MLWastesSwarm:
    def __init__(self, save_file="wastes_state.json", width=80, height=30, 
                 biome='wastes', split_biomes=None, force_new=False):
        self.save_file = Path(save_file)
        self.width = width
        self.height = height
        
        # Define biomes FIRST
        self.biomes = {
            'wastes': {
                'base': '.',
                'symbols': ['#', '@', '%', '0', '1', 'x', '~', '^', 'o', '*']
            },
            'forest': {
                'base': '.',
                'symbols': ['T', 't', '0', '~', '=', '%', '@', '^']
            },
            'plains': {
                'base': ',',
                'symbols': ['%', '~', '*', '.', '|', '^', '=', '#']
            }
        }
        
        # Pattern matching for swarm text
        self.patterns = {
            '@': ['terminal', 'screen', 'display', 'monitor', 'console'],
            'S': ['snake', 'silver', 'circuit', 'trace', 'corruption'],
            '~': ['stream', 'data', 'flow', 'river', 'current'],
            '0': ['null', 'void', 'empty', 'zero', 'nothing'],
            '=': ['balanced', 'stable', 'calm', 'equilibrium'],
            '%': ['tangle', 'bramble', 'overflow', 'chaos', 'mess'],
            'T': ['tree', 'binary', 'node', 'parent', 'root'],
            'o': ['debris', 'rubble', 'junk', 'waste', 'broken'],
            'x': ['crash', 'error', 'fail', 'broken', 'dead'],
            '^': ['spike', 'peak', 'sharp', 'danger', 'warning'],
            '#': ['server', 'rack', 'hardware', 'machine'],
            '1': ['bit', 'binary', 'one', 'digital'],
            '*': ['spark', 'flash', 'bright', 'electric'],
            '.': ['ground', 'empty', 'clear', 'default'],
            '|': ['flag', 'pole', 'vertical', 'barrier']
        }
        
        # NOW load or create state
        if self.save_file.exists() and not force_new:
            with open(self.save_file) as f:
                self.state = json.load(f)
        else:
            self.state = self.new_game(biome, split_biomes)
            self.save()
    
    def generate_terrain(self, biome, split_biomes):
        """Generate initial terrain"""
        grid = [['.' for _ in range(self.width)] for _ in range(self.height)]
        
        biome_zones = []
        if split_biomes and len(split_biomes) > 1:
            zone_height = self.height // len(split_biomes)
            for i, b in enumerate(split_biomes):
                start_y = i * zone_height
                end_y = (i + 1) * zone_height if i = 5:
            self.major_perturbation()
            self.state["ep"] = 0
        
        self.state["perturbations"] += 1
        self.state["last_input"] = text[:100]
    
    def major_perturbation(self):
        """Large-scale map change"""
        event_type = random.choice(['biome_shift', 'data_stream', 'null_zone', 'entity_spawn'])
        
        if event_type == 'biome_shift':
            # Randomize section
            for _ in range(200):
                x = random.randint(0, self.width - 1)
                y = random.randint(0, self.height - 1)
                self.state["map"][y][x] = random.choice(['@', '%', '~', '0', '=', 'T', 'o', 'x', '^'])
        
        elif event_type == 'data_stream':
            # Horizontal stream
            y = random.randint(5, self.height - 5)
            for x in range(self.width):
                self.state["map"][y][x] = '~'
                if random.random() > 0.8:
                    y = max(0, min(self.height - 1, y + random.choice([-1, 1])))
        
        elif event_type == 'null_zone':
            # Circular void
            cx = random.randint(10, self.width - 10)
            cy = random.randint(5, self.height - 5)
            radius = random.randint(3, 6)
            for y in range(max(0, cy - radius), min(self.height, cy + radius)):
                for x in range(max(0, cx - radius), min(self.width, cx + radius)):
                    if ((x - cx) ** 2 + (y - cy) ** 2) ** 0.5 <= radius:
                        self.state["map"][y][x] = '0'
        
        elif event_type == 'entity_spawn':
            # Add silver snakes
            for _ in range(random.randint(3, 8)):
                x = random.randint(0, self.width - 1)
                y = random.randint(0, self.height - 1)
                self.state["map"][y][x] = 'S'
    
    def render_map(self):
        """Output current map state"""
        output = []
        for row in self.state["map"]:
            output.append("".join(row))
        return "\n".join(output)
    
    def get_stats(self):
        """Return current state info"""
        return {
            "perturbations": self.state["perturbations"],
            "ep": self.state["ep"],
            "last_input": self.state["last_input"],
            "map_hash": hash(str(self.state["map"]))
        }

def main():
    parser = argparse.ArgumentParser(description="MLWastesSwarm - Map Perturbation")
    parser.add_argument('--width', type=int, default=80)
    parser.add_argument('--height', type=int, default=30)
    parser.add_argument('--biome', default='wastes', choices=['wastes', 'forest', 'plains'])
    parser.add_argument('--split', nargs='+', choices=['wastes', 'forest', 'plains'])
    parser.add_argument('--new', action='store_true', help='Force new map')
    parser.add_argument('--save', default='wastes_state.json')
    parser.add_argument('--render', action='store_true', help='Output map after processing')
    
    args = parser.parse_args()
    
    game = MLWastesSwarm(save_file=args.save, width=args.width, height=args.height,
                         biome=args.biome, split_biomes=args.split, force_new=args.new)
    
    # Check if stdin has data (non-blocking)
    if sys.stdin.isatty():
        # Terminal attached, no piped input
        input_text = ""
    else:
        # Read piped input
        input_text = sys.stdin.read().strip()
    
    if input_text:
        game.perturb_map(input_text)
        game.save()
        
        if args.render:
            print(game.render_map())
            print("-" * 80)
        
        # Output stats
        stats = game.get_stats()
        print(f"Perturbation #{stats['perturbations']} | EP: {stats['ep']}/5 | Map hash: {stats['map_hash']}")
        print(f"Processed: {stats['last_input'][:50]}...")
    else:
        # No input, just render current state if requested
        if args.render:
            print(game.render_map())
            print("-" * 80)
            stats = game.get_stats()
            print(f"Current state: Perturbations: {stats['perturbations']} | EP: {stats['ep']}/5")

if __name__ == "__main__":
    main()