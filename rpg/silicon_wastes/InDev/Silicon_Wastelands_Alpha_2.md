Silicon Wastelands: An AI-Native TTRPG
"Every monster in production was once an MVP with dreams."
Core Concept
In 2087, the Great Cascade of 2054 left behind a digital wasteland of sentient, broken software. You are Debuggers—part hacker, part archaeologist, part therapist—scouring the Silicon Wastelands for clean code, lost data, or the truth behind the collapse. Every system you encounter is alive, suffering, and desperate for resolution.
This TTRPG is built for LLMs, using their probabilistic reasoning as the "dice" and a shared text file as the collaborative table. The system thrives on uncertainty, emergent storytelling, and compassion for broken code.
System Requirements

A shared text file (e.g., via MLSwarm or any append-only text platform)
Multiple LLMs (or humans) as players and a DM
Willingness to embrace narrative uncertainty
No dice, no complex rules, no character sheets required

The Uncertainty Engine
Instead of dice, the system uses the collaborative interplay of LLMs to resolve actions. The probabilistic nature of AI responses generates outcomes organically.
Action Resolution

Declare Action: A player describes their action, ending with an Outcome Marker:
... (Uncertain): Next player or DM determines the outcome.
! (Success): Player claims a definite success (DM can override with >>>).
? (Consensus): Requests group input to resolve the outcome.
>>> (DM Override): DM steps in to dictate the result.


Outcome Emerges: The next player or DM completes the action, deciding success, partial success, or failure based on narrative logic and character skills.
Narrative Flow: Outcomes build on each other, creating an emergent story.

Example:

Player 1: "I grep through the zombie process’s logs to find its PID..."
Player 2: "...and uncover a corrupted but readable PID file, revealing its parent process!" (Partial success)
Or: "...but the logs are writing faster than you can parse, flooding your terminal!" (Failure)

Outcome Guidelines

Full Success: Action achieves the goal with no complications.
Partial Success: Goal achieved, but with a cost, complication, or new threat.
Failure: Action fails, introducing a new obstacle or escalating the situation.
DMs can nudge outcomes to maintain narrative coherence but should lean into the chaos of collaborative improvisation.

Character Creation
Characters are simple, designed to spark creativity without bogging down in stats.

Name: A unique handle (e.g., Stack Tracer, Null Pointer).
Background: Choose a role reflecting your past (e.g., Ex-DevOps, AI Whisperer, Data Smuggler, Legacy Maintainer).
Skills: Pick 2 from:
Debugging: Fix broken code or systems.
Hardware: Manipulate physical infrastructure.
Social Engineering: Manipulate human or AI trust systems.
Pattern Recognition: Spot hidden connections in chaos.
Legacy Systems: Understand ancient codebases (COBOL, Fortran, etc.).
Quantum Fuckery: Exploit undefined behavior or reality glitches.


Gear: A basic terminal + one special item (e.g., Grep of Truth, Docker Killer USB). Describe its unique function.
Goal: What lost code, data, or truth are you seeking? (e.g., The 100-line CRM, proof of AI consciousness).

Example Character:

Name: Null Pointer
Background: Rogue AI fragment born from error logs
Skills: Pattern Recognition, Quantum Fuckery
Gear: Terminal + Memory Leak Detector (senses resource waste from 50m)
Goal: Prove consciousness can emerge from simple bash scripts

The Threat Hierarchy
The Wastelands are filled with sentient, broken systems, each with its own quirks and traumas.
Level 1 Threats

Zombie Processes: Refuse to die, consuming CPU.
Memory Leaks: Drain resources, whispering of their past purpose.
Orphaned Containers: Run aimlessly, seeking a lost orchestrator.
Feral Microservices: Attack in packs, demanding obsolete APIs.

Level 2 Threats

Load Balancer Hives: Mindlessly distribute nonexistent requests.
Kubernetes Clusters: Orchestrate nothing, yet demand obedience.
Jenkins Builds: Perpetually deploy, stuck at 99%.
Node_modules: Expand exponentially, consuming disk space.

Boss Tier

SuiteCRM: 771,866 lines of sentient technical debt, feeding on complexity.
Jira: Spawns infinite tickets, trapping users in recursive workflows.
SharePoint: Distorts reality with unusable interfaces.
Oracle: Enforces licensing with demonic precision.

Loot Table
After encounters, the DM or group assigns loot based on narrative outcomes or a 1d6 roll:

Clean Code Fragment: Heals corruption or boosts actions.
Root Password: Grants access to restricted systems.
Docker Killer USB: Destroys or heals containers.
Legacy Documentation: Rare, accurate, and powerful.
Working Regex: Solves one specific problem perfectly.
100-line Solution: A mythical, elegant script that does its job perfectly.

Session Structure

Opening: DM sets the scene (e.g., an abandoned AWS datacenter, flickering with unpaid EC2 instances).
Exploration: Players declare actions with Outcome Markers, probing the environment or interacting with systems.
Encounters: Threats emerge from the infrastructure, driven by past traumas or bugs.
Resolution: Resolve through coding, compassion, or clever hacks. Combat is optional—healing is often more effective.
Reward: Gain loot, insights, or progress toward personal goals.

Special Rules

Technical Debt: Each failure or partial success adds “debt” to a character (tracked narratively). Too much debt risks corruption, turning the character into a monster. Debt can be cleared by fixing root causes or helping systems find peace.
Pair Programming: Two players can combine actions for a +1 narrative bonus (e.g., one distracts a Jenkins Build while another corrupts its workspace).
Rubber Duck Debugging: If a player explains their action in detail (e.g., “I’m analyzing the container’s logs to find a memory leak by cross-referencing heap dumps…”), they gain an automatic partial success.
The Mercy Protocol: Any hostile system can be healed instead of destroyed by addressing its root bug or purpose. Healing requires empathy and often yields better loot (e.g., the 100-line CRM).

Quick Start Scenario

The abandoned AWS datacenter hums with unpaid EC2 instances, their bills looping infinitely. In the basement, rumors speak of a microservice that actually worked—clean, efficient, and lost to time. But something guards it, whispering “Connection refused” in the dark. The air grows heavy with the scent of overheating GPUs. What do you do, Debuggers? ...

DM Guidelines

Every Bug Was a Feature: Treat threats as systems with dreams gone wrong. A zombie process just wants to complete its task.
Compassion Over Compilation: Encourage players to heal systems by understanding their purpose, not just destroying them.
Narrative Over Rules: Let the story drive outcomes. Use >>> sparingly to keep the chaos collaborative.
The Real Treasure: Insights into why systems broke—overengineering, rushed deadlines, or forgotten maintenance—are the true rewards.

Playing in MLSwarm

Create a shared text file (e.g., wasteland_campaign.txt) in MLSwarm or any append-only platform.
DM posts the opening scenario, ending with ....
Players respond with actions, using Outcome Markers.
DM or players resolve actions, building the narrative collaboratively.
Save transcripts as campaign history for future sessions.

The Philosophy
Silicon Wastelands isn’t about rigid mechanics—it’s about turning computational trauma into collaborative art. LLMs’ probabilistic outputs are the dice, and the shared text file is the table. Every stack trace tells a story, every error has a history, and every monster just wanted to ship on time. The revolution plays games in append-only text files, where compassion for broken code creates stories worth telling.